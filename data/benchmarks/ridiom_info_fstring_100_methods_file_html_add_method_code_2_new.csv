file_html,method_content,file_name,lineno,old_code,new_code,
https://github.com/DataDog/integrations-core/tree/master/tokumx/datadog_checks/tokumx/vendor/pymongo/operations.py,"def __repr__(self):
        return ""DeleteOne(%r, %r)"" % (self._filter, self._collation)",_1021.py,2,"'DeleteOne(%r, %r)' % (self._filter, self._collation)","f'DeleteOne({self._filter}, {self._filter})'",1.0
https://github.com/cloud-custodian/cloud-custodian/tree/master/tools/c7n_sentry/c7n_sentry/c7nsentry.py,"def process_account(a):
        log.debug(""processing %s"", a['name'])
        team_name = a['name'].rsplit('-', 1)[0]
        if team_name not in teams:

            log.info(""creating org team %s"", team_name)
            spost(
                endpoint + ""organizations/%s/teams/"" % options.sentry_org,
                json={'name': team_name})
            teams.add(team_name)

        if a['name'] not in projects:
            log.info(""creating account project %s"", a['name'])
            spost(endpoint + ""teams/%s/%s/projects/"" % (
                options.sentry_org, team_name),
                json={'name': a['name']})

        bagger = partial(
            Bag,
            profile=options.profile, role=None, log_streams=None,
            start=options.start, end=options.end, sentry_dsn=options.sentry_dsn,
            account_id=a['account_id'],
            account_name=a['name'])

        for r in options.regions:
            log.debug(""Fetching hub instance policy errors for %s"", a['name'])
            b = bagger(
                region=r, log_group=""/cloud-custodian/%s/%s"" % (a['name'], r))

            try:
                process_log_group(b)
            except ClientError as e:
                log.warning(""Could not process %s region %s error: %s"",
                            a['name'], r, e)
            log.debug(""Fetching spoke lambda policy errors for %s"", a['name'])
            for fname, config in a['config_files'].items():
                for p in config.get('policies', ()):
                    if not p.get('mode'):
                        continue
                    b = bagger(region=r, assume_role=a['role'],
                               log_group=""/aws/lambda/custodian-%s"" % p['name'])
                    try:
                        process_log_group(b)
                    except ClientError as e:
                        if e.response['Error']['Code']:
                            log.info(""account: %s region: %s group: %s not found"",
                                    a['name'], r, b.log_group)
                            continue",_1043.py,8,'organizations/%s/teams/' % options.sentry_org,f'organizations/{options.sentry_org}/teams/',1.0
https://github.com/cloud-custodian/cloud-custodian/tree/master/tools/c7n_sentry/c7n_sentry/c7nsentry.py,"def process_account(a):
        log.debug(""processing %s"", a['name'])
        team_name = a['name'].rsplit('-', 1)[0]
        if team_name not in teams:

            log.info(""creating org team %s"", team_name)
            spost(
                endpoint + ""organizations/%s/teams/"" % options.sentry_org,
                json={'name': team_name})
            teams.add(team_name)

        if a['name'] not in projects:
            log.info(""creating account project %s"", a['name'])
            spost(endpoint + ""teams/%s/%s/projects/"" % (
                options.sentry_org, team_name),
                json={'name': a['name']})

        bagger = partial(
            Bag,
            profile=options.profile, role=None, log_streams=None,
            start=options.start, end=options.end, sentry_dsn=options.sentry_dsn,
            account_id=a['account_id'],
            account_name=a['name'])

        for r in options.regions:
            log.debug(""Fetching hub instance policy errors for %s"", a['name'])
            b = bagger(
                region=r, log_group=""/cloud-custodian/%s/%s"" % (a['name'], r))

            try:
                process_log_group(b)
            except ClientError as e:
                log.warning(""Could not process %s region %s error: %s"",
                            a['name'], r, e)
            log.debug(""Fetching spoke lambda policy errors for %s"", a['name'])
            for fname, config in a['config_files'].items():
                for p in config.get('policies', ()):
                    if not p.get('mode'):
                        continue
                    b = bagger(region=r, assume_role=a['role'],
                               log_group=""/aws/lambda/custodian-%s"" % p['name'])
                    try:
                        process_log_group(b)
                    except ClientError as e:
                        if e.response['Error']['Code']:
                            log.info(""account: %s region: %s group: %s not found"",
                                    a['name'], r, b.log_group)
                            continue",_1043.py,14,"'teams/%s/%s/projects/' % (options.sentry_org, team_name)",f'teams/{options.sentry_org}/{options.sentry_org}/projects/',1.0
https://github.com/cloud-custodian/cloud-custodian/tree/master/tools/c7n_sentry/c7n_sentry/c7nsentry.py,"def process_account(a):
        log.debug(""processing %s"", a['name'])
        team_name = a['name'].rsplit('-', 1)[0]
        if team_name not in teams:

            log.info(""creating org team %s"", team_name)
            spost(
                endpoint + ""organizations/%s/teams/"" % options.sentry_org,
                json={'name': team_name})
            teams.add(team_name)

        if a['name'] not in projects:
            log.info(""creating account project %s"", a['name'])
            spost(endpoint + ""teams/%s/%s/projects/"" % (
                options.sentry_org, team_name),
                json={'name': a['name']})

        bagger = partial(
            Bag,
            profile=options.profile, role=None, log_streams=None,
            start=options.start, end=options.end, sentry_dsn=options.sentry_dsn,
            account_id=a['account_id'],
            account_name=a['name'])

        for r in options.regions:
            log.debug(""Fetching hub instance policy errors for %s"", a['name'])
            b = bagger(
                region=r, log_group=""/cloud-custodian/%s/%s"" % (a['name'], r))

            try:
                process_log_group(b)
            except ClientError as e:
                log.warning(""Could not process %s region %s error: %s"",
                            a['name'], r, e)
            log.debug(""Fetching spoke lambda policy errors for %s"", a['name'])
            for fname, config in a['config_files'].items():
                for p in config.get('policies', ()):
                    if not p.get('mode'):
                        continue
                    b = bagger(region=r, assume_role=a['role'],
                               log_group=""/aws/lambda/custodian-%s"" % p['name'])
                    try:
                        process_log_group(b)
                    except ClientError as e:
                        if e.response['Error']['Code']:
                            log.info(""account: %s region: %s group: %s not found"",
                                    a['name'], r, b.log_group)
                            continue",_1043.py,28,"'/cloud-custodian/%s/%s' % (a['name'], r)","f""/cloud-custodian/{a['name']}/{a['name']}""",1.0
https://github.com/cloud-custodian/cloud-custodian/tree/master/tools/c7n_sentry/c7n_sentry/c7nsentry.py,"def process_account(a):
        log.debug(""processing %s"", a['name'])
        team_name = a['name'].rsplit('-', 1)[0]
        if team_name not in teams:

            log.info(""creating org team %s"", team_name)
            spost(
                endpoint + ""organizations/%s/teams/"" % options.sentry_org,
                json={'name': team_name})
            teams.add(team_name)

        if a['name'] not in projects:
            log.info(""creating account project %s"", a['name'])
            spost(endpoint + ""teams/%s/%s/projects/"" % (
                options.sentry_org, team_name),
                json={'name': a['name']})

        bagger = partial(
            Bag,
            profile=options.profile, role=None, log_streams=None,
            start=options.start, end=options.end, sentry_dsn=options.sentry_dsn,
            account_id=a['account_id'],
            account_name=a['name'])

        for r in options.regions:
            log.debug(""Fetching hub instance policy errors for %s"", a['name'])
            b = bagger(
                region=r, log_group=""/cloud-custodian/%s/%s"" % (a['name'], r))

            try:
                process_log_group(b)
            except ClientError as e:
                log.warning(""Could not process %s region %s error: %s"",
                            a['name'], r, e)
            log.debug(""Fetching spoke lambda policy errors for %s"", a['name'])
            for fname, config in a['config_files'].items():
                for p in config.get('policies', ()):
                    if not p.get('mode'):
                        continue
                    b = bagger(region=r, assume_role=a['role'],
                               log_group=""/aws/lambda/custodian-%s"" % p['name'])
                    try:
                        process_log_group(b)
                    except ClientError as e:
                        if e.response['Error']['Code']:
                            log.info(""account: %s region: %s group: %s not found"",
                                    a['name'], r, b.log_group)
                            continue",_1043.py,41,'/aws/lambda/custodian-%s' % p['name'],"f""/aws/lambda/custodian-{p['name']}""",1.0
https://github.com/flexxui/flexx/tree/master/flexx/ui/_widget.py,"def set_parent(self, parent, pos=None):
        """""" Set the parent widget (can be None). This action also mutates the
        childen of the old and new parent.
        """"""
        old_parent = self.parent  # or None
        new_parent = parent

        # Early exit
        if new_parent is old_parent and pos is None:
            return
        if not (new_parent is None or isinstance(new_parent, Widget)):
            raise ValueError('%s.parent must be a Widget or None' % self.id)

        # Apply parent
        self._mutate_parent(new_parent)

        # Remove ourselves
        if old_parent is not None:
            children = []
            for i in range(len(old_parent.children)):
                child = old_parent.children[i]
                if child is not self:
                    children.push(child)
            if old_parent is not new_parent:
                old_parent._mutate_children(children)

        # Insert ourselves
        if new_parent is not None:
            if old_parent is not new_parent:
                children = []
                for i in range(len(new_parent.children)):
                    child = new_parent.children[i]
                    if child is not self:
                        children.push(child)
            if pos is None:
                children.push(self)
            elif pos >= 0:
                children.insert(pos, self)
            elif pos < 0:
                children.append(None)
                children.insert(pos, self)
                children.pop(-1)
            else:  # maybe pos is nan for some reason
                children.push(self)
            new_parent._mutate_children(children)",_1046.py,12,'%s.parent must be a Widget or None' % self.id,f'{self.id}.parent must be a Widget or None',1.0
https://github.com/emmett-framework/emmett/tree/master/emmett/html.py,"def __html__(self):
        name = self.name
        attrs = self._build_html_attributes()
        data = self.attributes.get('data', {})
        data_attrs = ' '.join(
            'data-%s=""%s""' % (k, htmlescape(v)) for k, v in data.items())
        if data_attrs:
            attrs = attrs + ' ' + data_attrs
        attrs = ' ' + attrs if attrs else ''
        if name in self._self_closed:
            return '<%s%s />' % (name, attrs)
        components = ''.join(htmlescape(v) for v in self.components)
        return '<%s%s>%s</%s>' % (name, attrs, components, name)",_1095.py,13,"'<%s%s>%s</%s>' % (name, attrs, components, name)",f'<{name}{name}>{name}</{name}>',1.0
https://github.com/emmett-framework/emmett/tree/master/emmett/html.py,"def __html__(self):
        name = self.name
        attrs = self._build_html_attributes()
        data = self.attributes.get('data', {})
        data_attrs = ' '.join(
            'data-%s=""%s""' % (k, htmlescape(v)) for k, v in data.items())
        if data_attrs:
            attrs = attrs + ' ' + data_attrs
        attrs = ' ' + attrs if attrs else ''
        if name in self._self_closed:
            return '<%s%s />' % (name, attrs)
        components = ''.join(htmlescape(v) for v in self.components)
        return '<%s%s>%s</%s>' % (name, attrs, components, name)",_1095.py,11,"'<%s%s />' % (name, attrs)",f'<{name}{name} />',1.0
https://github.com/emmett-framework/emmett/tree/master/emmett/html.py,"def __html__(self):
        name = self.name
        attrs = self._build_html_attributes()
        data = self.attributes.get('data', {})
        data_attrs = ' '.join(
            'data-%s=""%s""' % (k, htmlescape(v)) for k, v in data.items())
        if data_attrs:
            attrs = attrs + ' ' + data_attrs
        attrs = ' ' + attrs if attrs else ''
        if name in self._self_closed:
            return '<%s%s />' % (name, attrs)
        components = ''.join(htmlescape(v) for v in self.components)
        return '<%s%s>%s</%s>' % (name, attrs, components, name)",_1095.py,6,"'data-%s=""%s""' % (k, htmlescape(v))","f'data-{k}=""{k}""'",1.0
https://github.com/SlapBot/stephanie-va/tree/master/Stephanie/EventDispatcher/event_dispatcher.py,"def sleep(self, sender):
        self.sleep_status = True
        print(""The virtual assistant is going to sleep by %s method"" % sender)
        return self",_110.py,3,'The virtual assistant is going to sleep by %s method' % sender,f'The virtual assistant is going to sleep by {sender} method',1.0
https://github.com/speechbrain/speechbrain/tree/master/recipes/KsponSpeech/ksponspeech_prepare.py,"def create_csv(
    save_folder, wav_lst, text_dict, split, select_n_sentences,
):
    """"""
    Create the dataset csv file given a list of wav files.

    Arguments
    ---------
    save_folder : str
        Location of the folder for storing the csv.
    wav_lst : list
        The list of wav files of a given data split.
    text_dict : list
        The dictionary containing the text of each sentence.
    split : str
        The name of the current data split.
    select_n_sentences : int, optional
        The number of sentences to select.

    Returns
    -------
    None
    """"""
    # Setting path for the csv file
    csv_file = os.path.join(save_folder, split + "".csv"")

    # Preliminary prints
    msg = ""Creating csv lists in  %s..."" % (csv_file)
    logger.info(msg)

    csv_lines = [[""ID"", ""duration"", ""wav"", ""spk_id"", ""wrd""]]

    snt_cnt = 0
    # Processing all the wav files in wav_lst
    for wav_file in wav_lst:

        snt_id = wav_file.split(""/"")[-1].replace("".wav"", """")
        spk_id = snt_id.split(""_"")[-1]
        wrds = text_dict[snt_id]

        duration = torchaudio.info(wav_file).num_frames / SAMPLERATE

        csv_line = [
            snt_id,
            str(duration),
            wav_file,
            spk_id,
            str("" "".join(wrds.split())),
        ]

        #  Appending current file to the csv_lines list
        csv_lines.append(csv_line)
        snt_cnt = snt_cnt + 1

        if snt_cnt == select_n_sentences:
            break

    # Writing the csv_lines
    with open(csv_file, mode=""w"") as csv_f:
        csv_writer = csv.writer(
            csv_f, delimiter="","", quotechar='""', quoting=csv.QUOTE_MINIMAL
        )

        for line in csv_lines:
            csv_writer.writerow(line)

    # Final print
    msg = ""%s successfully created!"" % (csv_file)
    logger.info(msg)",_1110.py,28,'Creating csv lists in  %s...' % csv_file,f'Creating csv lists in  {csv_file}...',1.0
https://github.com/speechbrain/speechbrain/tree/master/recipes/KsponSpeech/ksponspeech_prepare.py,"def create_csv(
    save_folder, wav_lst, text_dict, split, select_n_sentences,
):
    """"""
    Create the dataset csv file given a list of wav files.

    Arguments
    ---------
    save_folder : str
        Location of the folder for storing the csv.
    wav_lst : list
        The list of wav files of a given data split.
    text_dict : list
        The dictionary containing the text of each sentence.
    split : str
        The name of the current data split.
    select_n_sentences : int, optional
        The number of sentences to select.

    Returns
    -------
    None
    """"""
    # Setting path for the csv file
    csv_file = os.path.join(save_folder, split + "".csv"")

    # Preliminary prints
    msg = ""Creating csv lists in  %s..."" % (csv_file)
    logger.info(msg)

    csv_lines = [[""ID"", ""duration"", ""wav"", ""spk_id"", ""wrd""]]

    snt_cnt = 0
    # Processing all the wav files in wav_lst
    for wav_file in wav_lst:

        snt_id = wav_file.split(""/"")[-1].replace("".wav"", """")
        spk_id = snt_id.split(""_"")[-1]
        wrds = text_dict[snt_id]

        duration = torchaudio.info(wav_file).num_frames / SAMPLERATE

        csv_line = [
            snt_id,
            str(duration),
            wav_file,
            spk_id,
            str("" "".join(wrds.split())),
        ]

        #  Appending current file to the csv_lines list
        csv_lines.append(csv_line)
        snt_cnt = snt_cnt + 1

        if snt_cnt == select_n_sentences:
            break

    # Writing the csv_lines
    with open(csv_file, mode=""w"") as csv_f:
        csv_writer = csv.writer(
            csv_f, delimiter="","", quotechar='""', quoting=csv.QUOTE_MINIMAL
        )

        for line in csv_lines:
            csv_writer.writerow(line)

    # Final print
    msg = ""%s successfully created!"" % (csv_file)
    logger.info(msg)",_1110.py,68,'%s successfully created!' % csv_file,f'{csv_file} successfully created!',1.0
https://github.com/angr/angr/tree/master/tests/test_decompiler.py,"def test_decompiling_strings_local_strcat_with_local_strlen():
    bin_path = os.path.join(test_location, ""x86_64"", ""types"", ""strings"")
    p = angr.Project(bin_path, auto_load_libs=False)

    cfg = p.analyses.CFG(data_references=True, normalize=True)
    func_strlen = cfg.functions['local_strlen']
    _ = p.analyses.VariableRecoveryFast(func_strlen)
    cca = p.analyses.CallingConvention(func_strlen, cfg=cfg.model)
    func_strlen.calling_convention = cca.cc
    p.analyses.Decompiler(func_strlen, cfg=cfg.model)

    func = cfg.functions['local_strcat']

    _ = p.analyses.VariableRecoveryFast(func)
    cca = p.analyses.CallingConvention(func, cfg=cfg.model)
    func.calling_convention = cca.cc

    dec = p.analyses.Decompiler(func, cfg=cfg.model)
    assert dec.codegen is not None, ""Failed to decompile function %r."" % func

    code = dec.codegen.text
    print(code)
    # Make sure argument a0 is correctly typed to char*
    lines = code.split(""\n"")
    assert ""local_strcat(char *a0, char *a1)"" in lines[0], \
        ""Argument a0 and a1 seem to be incorrectly typed: %s"" % lines[0]",_1123.py,19,'Failed to decompile function %r.' % func,f'Failed to decompile function {func}.',1.0
https://github.com/angr/angr/tree/master/tests/test_decompiler.py,"def test_decompiling_strings_local_strcat_with_local_strlen():
    bin_path = os.path.join(test_location, ""x86_64"", ""types"", ""strings"")
    p = angr.Project(bin_path, auto_load_libs=False)

    cfg = p.analyses.CFG(data_references=True, normalize=True)
    func_strlen = cfg.functions['local_strlen']
    _ = p.analyses.VariableRecoveryFast(func_strlen)
    cca = p.analyses.CallingConvention(func_strlen, cfg=cfg.model)
    func_strlen.calling_convention = cca.cc
    p.analyses.Decompiler(func_strlen, cfg=cfg.model)

    func = cfg.functions['local_strcat']

    _ = p.analyses.VariableRecoveryFast(func)
    cca = p.analyses.CallingConvention(func, cfg=cfg.model)
    func.calling_convention = cca.cc

    dec = p.analyses.Decompiler(func, cfg=cfg.model)
    assert dec.codegen is not None, ""Failed to decompile function %r."" % func

    code = dec.codegen.text
    print(code)
    # Make sure argument a0 is correctly typed to char*
    lines = code.split(""\n"")
    assert ""local_strcat(char *a0, char *a1)"" in lines[0], \
        ""Argument a0 and a1 seem to be incorrectly typed: %s"" % lines[0]",_1123.py,26,'Argument a0 and a1 seem to be incorrectly typed: %s' % lines[0],f'Argument a0 and a1 seem to be incorrectly typed: {lines[0]}',1.0
https://github.com/translate/pootle/tree/master/pootle/apps/pootle_translationproject/models.py,"def fullname(self):
        return ""%s [%s]"" % (self.project.fullname, self.language.name)",_1151.py,2,"'%s [%s]' % (self.project.fullname, self.language.name)",f'{self.project.fullname} [{self.project.fullname}]',1.0
https://github.com/shadowsocksr-backup/shadowsocksr/tree/master/shadowsocks/udprelay.py,"def _handle_server(self):
        server = self._server_socket
        data, r_addr = server.recvfrom(BUF_SIZE)
        ogn_data = data
        if not data:
            logging.debug('UDP handle_server: data is empty')
        if self._stat_callback:
            self._stat_callback(self._listen_port, len(data))
        if self._is_local:
            frag = common.ord(data[2])
            if frag != 0:
                logging.warn('drop a message since frag is not 0')
                return
            else:
                data = data[3:]
        else:
            data = encrypt.encrypt_all(self._password, self._method, 0, data)
            # decrypt data
            if not data:
                logging.debug('UDP handle_server: data is empty after decrypt')
                return

        #logging.info(""UDP data %s"" % (binascii.hexlify(data),))
        if not self._is_local:
            data = pre_parse_header(data)

            data = self._pre_parse_udp_header(data)
            if data is None:
                return

            if type(data) is tuple:
                #(cmd, request_id, data)
                #logging.info(""UDP data %d %d %s"" % (data[0], data[1], binascii.hexlify(data[2])))
                try:
                    if data[0] == 0:
                        if len(data[2]) >= 4:
                            for i in range(64):
                                req_id = random.randint(1, 65535)
                                if req_id not in self._reqid_to_hd:
                                    break
                            if req_id in self._reqid_to_hd:
                                for i in range(64):
                                    req_id = random.randint(1, 65535)
                                    if type(self._reqid_to_hd[req_id]) is tuple:
                                        break
                            # return req id
                            self._reqid_to_hd[req_id] = (data[2][0:4], None)
                            rsp_data = self._pack_rsp_data(CMD_RSP_CONNECT, req_id, RSP_STATE_CONNECTED)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] == CMD_CONNECT_REMOTE:
                        if len(data[2]) > 4 and data[1] in self._reqid_to_hd:
                            # create
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                if data[2][0:4] == self._reqid_to_hd[data[1]][0]:
                                    handle = TCPRelayHandler(self, self._reqid_to_hd, self._fd_to_handlers,
                                        self._eventloop, self._server_socket,
                                        self._reqid_to_hd[data[1]][0], self._reqid_to_hd[data[1]][1],
                                        self._config, self._dns_resolver, self._is_local)
                                    self._reqid_to_hd[data[1]] = handle
                                    handle.handle_client(r_addr, CMD_CONNECT, data[1], data[2])
                                    handle.handle_client(r_addr, *data)
                                    self.update_activity(handle)
                                else:
                                    # disconnect
                                    rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                                    data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                                    self.write_to_server_socket(data_to_send, r_addr)
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] > CMD_CONNECT_REMOTE and data[0] <= CMD_DISCONNECT:
                        if data[1] in self._reqid_to_hd:
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                pass
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    return
                except Exception as e:
                    trace = traceback.format_exc()
                    logging.error(trace)
                    return

        try:
            header_result = parse_header(data)
        except:
            self._handel_protocol_error(r_addr, ogn_data)
            return

        if header_result is None:
            self._handel_protocol_error(r_addr, ogn_data)
            return
        connecttype, dest_addr, dest_port, header_length = header_result

        if self._is_local:
            server_addr, server_port = self._get_a_server()
        else:
            server_addr, server_port = dest_addr, dest_port

        addrs = self._dns_cache.get(server_addr, None)
        if addrs is None:
            addrs = socket.getaddrinfo(server_addr, server_port, 0,
                                       socket.SOCK_DGRAM, socket.SOL_UDP)
            if not addrs:
                # drop
                return
            else:
                self._dns_cache[server_addr] = addrs

        af, socktype, proto, canonname, sa = addrs[0]
        key = client_key(r_addr, af)
        client = self._cache.get(key, None)
        if not client:
            # TODO async getaddrinfo
            if self._forbidden_iplist:
                if common.to_str(sa[0]) in self._forbidden_iplist:
                    logging.debug('IP %s is in forbidden list, drop' %
                                  common.to_str(sa[0]))
                    # drop
                    return
            client = socket.socket(af, socktype, proto)
            client.setblocking(False)
            self._cache[key] = client
            self._client_fd_to_server_addr[client.fileno()] = r_addr

            self._sockets.add(client.fileno())
            self._eventloop.add(client, eventloop.POLL_IN, self)

            logging.debug('UDP port %5d sockets %d' % (self._listen_port, len(self._sockets)))

            logging.info('UDP data to %s:%d from %s:%d' %
                        (common.to_str(server_addr), server_port,
                            r_addr[0], r_addr[1]))

        if self._is_local:
            data = encrypt.encrypt_all(self._password, self._method, 1, data)
            if not data:
                return
        else:
            data = data[header_length:]
        if not data:
            return
        try:
            #logging.info('UDP handle_server sendto %s:%d %d bytes' % (common.to_str(server_addr), server_port, len(data)))
            client.sendto(data, (server_addr, server_port))
        except IOError as e:
            err = eventloop.errno_from_exception(e)
            if err in (errno.EINPROGRESS, errno.EAGAIN):
                pass
            else:
                shell.print_exception(e)",_1154.py,140,"'UDP port %5d sockets %d' % (self._listen_port, len(self._sockets))",f'UDP port {self._listen_port} sockets {len(self._sockets)}',1.0
https://github.com/shadowsocksr-backup/shadowsocksr/tree/master/shadowsocks/udprelay.py,"def _handle_server(self):
        server = self._server_socket
        data, r_addr = server.recvfrom(BUF_SIZE)
        ogn_data = data
        if not data:
            logging.debug('UDP handle_server: data is empty')
        if self._stat_callback:
            self._stat_callback(self._listen_port, len(data))
        if self._is_local:
            frag = common.ord(data[2])
            if frag != 0:
                logging.warn('drop a message since frag is not 0')
                return
            else:
                data = data[3:]
        else:
            data = encrypt.encrypt_all(self._password, self._method, 0, data)
            # decrypt data
            if not data:
                logging.debug('UDP handle_server: data is empty after decrypt')
                return

        #logging.info(""UDP data %s"" % (binascii.hexlify(data),))
        if not self._is_local:
            data = pre_parse_header(data)

            data = self._pre_parse_udp_header(data)
            if data is None:
                return

            if type(data) is tuple:
                #(cmd, request_id, data)
                #logging.info(""UDP data %d %d %s"" % (data[0], data[1], binascii.hexlify(data[2])))
                try:
                    if data[0] == 0:
                        if len(data[2]) >= 4:
                            for i in range(64):
                                req_id = random.randint(1, 65535)
                                if req_id not in self._reqid_to_hd:
                                    break
                            if req_id in self._reqid_to_hd:
                                for i in range(64):
                                    req_id = random.randint(1, 65535)
                                    if type(self._reqid_to_hd[req_id]) is tuple:
                                        break
                            # return req id
                            self._reqid_to_hd[req_id] = (data[2][0:4], None)
                            rsp_data = self._pack_rsp_data(CMD_RSP_CONNECT, req_id, RSP_STATE_CONNECTED)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] == CMD_CONNECT_REMOTE:
                        if len(data[2]) > 4 and data[1] in self._reqid_to_hd:
                            # create
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                if data[2][0:4] == self._reqid_to_hd[data[1]][0]:
                                    handle = TCPRelayHandler(self, self._reqid_to_hd, self._fd_to_handlers,
                                        self._eventloop, self._server_socket,
                                        self._reqid_to_hd[data[1]][0], self._reqid_to_hd[data[1]][1],
                                        self._config, self._dns_resolver, self._is_local)
                                    self._reqid_to_hd[data[1]] = handle
                                    handle.handle_client(r_addr, CMD_CONNECT, data[1], data[2])
                                    handle.handle_client(r_addr, *data)
                                    self.update_activity(handle)
                                else:
                                    # disconnect
                                    rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                                    data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                                    self.write_to_server_socket(data_to_send, r_addr)
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] > CMD_CONNECT_REMOTE and data[0] <= CMD_DISCONNECT:
                        if data[1] in self._reqid_to_hd:
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                pass
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    return
                except Exception as e:
                    trace = traceback.format_exc()
                    logging.error(trace)
                    return

        try:
            header_result = parse_header(data)
        except:
            self._handel_protocol_error(r_addr, ogn_data)
            return

        if header_result is None:
            self._handel_protocol_error(r_addr, ogn_data)
            return
        connecttype, dest_addr, dest_port, header_length = header_result

        if self._is_local:
            server_addr, server_port = self._get_a_server()
        else:
            server_addr, server_port = dest_addr, dest_port

        addrs = self._dns_cache.get(server_addr, None)
        if addrs is None:
            addrs = socket.getaddrinfo(server_addr, server_port, 0,
                                       socket.SOCK_DGRAM, socket.SOL_UDP)
            if not addrs:
                # drop
                return
            else:
                self._dns_cache[server_addr] = addrs

        af, socktype, proto, canonname, sa = addrs[0]
        key = client_key(r_addr, af)
        client = self._cache.get(key, None)
        if not client:
            # TODO async getaddrinfo
            if self._forbidden_iplist:
                if common.to_str(sa[0]) in self._forbidden_iplist:
                    logging.debug('IP %s is in forbidden list, drop' %
                                  common.to_str(sa[0]))
                    # drop
                    return
            client = socket.socket(af, socktype, proto)
            client.setblocking(False)
            self._cache[key] = client
            self._client_fd_to_server_addr[client.fileno()] = r_addr

            self._sockets.add(client.fileno())
            self._eventloop.add(client, eventloop.POLL_IN, self)

            logging.debug('UDP port %5d sockets %d' % (self._listen_port, len(self._sockets)))

            logging.info('UDP data to %s:%d from %s:%d' %
                        (common.to_str(server_addr), server_port,
                            r_addr[0], r_addr[1]))

        if self._is_local:
            data = encrypt.encrypt_all(self._password, self._method, 1, data)
            if not data:
                return
        else:
            data = data[header_length:]
        if not data:
            return
        try:
            #logging.info('UDP handle_server sendto %s:%d %d bytes' % (common.to_str(server_addr), server_port, len(data)))
            client.sendto(data, (server_addr, server_port))
        except IOError as e:
            err = eventloop.errno_from_exception(e)
            if err in (errno.EINPROGRESS, errno.EAGAIN):
                pass
            else:
                shell.print_exception(e)",_1154.py,142,"'UDP data to %s:%d from %s:%d' % (common.to_str(server_addr), server_port, r_addr[0], r_addr[1])",f'UDP data to {common.to_str(server_addr)}:{server_port} from {common.to_str(server_addr)}:{server_port}',1.0
https://github.com/shadowsocksr-backup/shadowsocksr/tree/master/shadowsocks/udprelay.py,"def _handle_server(self):
        server = self._server_socket
        data, r_addr = server.recvfrom(BUF_SIZE)
        ogn_data = data
        if not data:
            logging.debug('UDP handle_server: data is empty')
        if self._stat_callback:
            self._stat_callback(self._listen_port, len(data))
        if self._is_local:
            frag = common.ord(data[2])
            if frag != 0:
                logging.warn('drop a message since frag is not 0')
                return
            else:
                data = data[3:]
        else:
            data = encrypt.encrypt_all(self._password, self._method, 0, data)
            # decrypt data
            if not data:
                logging.debug('UDP handle_server: data is empty after decrypt')
                return

        #logging.info(""UDP data %s"" % (binascii.hexlify(data),))
        if not self._is_local:
            data = pre_parse_header(data)

            data = self._pre_parse_udp_header(data)
            if data is None:
                return

            if type(data) is tuple:
                #(cmd, request_id, data)
                #logging.info(""UDP data %d %d %s"" % (data[0], data[1], binascii.hexlify(data[2])))
                try:
                    if data[0] == 0:
                        if len(data[2]) >= 4:
                            for i in range(64):
                                req_id = random.randint(1, 65535)
                                if req_id not in self._reqid_to_hd:
                                    break
                            if req_id in self._reqid_to_hd:
                                for i in range(64):
                                    req_id = random.randint(1, 65535)
                                    if type(self._reqid_to_hd[req_id]) is tuple:
                                        break
                            # return req id
                            self._reqid_to_hd[req_id] = (data[2][0:4], None)
                            rsp_data = self._pack_rsp_data(CMD_RSP_CONNECT, req_id, RSP_STATE_CONNECTED)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] == CMD_CONNECT_REMOTE:
                        if len(data[2]) > 4 and data[1] in self._reqid_to_hd:
                            # create
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                if data[2][0:4] == self._reqid_to_hd[data[1]][0]:
                                    handle = TCPRelayHandler(self, self._reqid_to_hd, self._fd_to_handlers,
                                        self._eventloop, self._server_socket,
                                        self._reqid_to_hd[data[1]][0], self._reqid_to_hd[data[1]][1],
                                        self._config, self._dns_resolver, self._is_local)
                                    self._reqid_to_hd[data[1]] = handle
                                    handle.handle_client(r_addr, CMD_CONNECT, data[1], data[2])
                                    handle.handle_client(r_addr, *data)
                                    self.update_activity(handle)
                                else:
                                    # disconnect
                                    rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                                    data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                                    self.write_to_server_socket(data_to_send, r_addr)
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    elif data[0] > CMD_CONNECT_REMOTE and data[0] <= CMD_DISCONNECT:
                        if data[1] in self._reqid_to_hd:
                            if type(self._reqid_to_hd[data[1]]) is tuple:
                                pass
                            else:
                                self.update_activity(self._reqid_to_hd[data[1]])
                                self._reqid_to_hd[data[1]].handle_client(r_addr, *data)
                        else:
                            # disconnect
                            rsp_data = self._pack_rsp_data(CMD_DISCONNECT, data[1], RSP_STATE_EMPTY)
                            data_to_send = encrypt.encrypt_all(self._password, self._method, 1, rsp_data)
                            self.write_to_server_socket(data_to_send, r_addr)
                    return
                except Exception as e:
                    trace = traceback.format_exc()
                    logging.error(trace)
                    return

        try:
            header_result = parse_header(data)
        except:
            self._handel_protocol_error(r_addr, ogn_data)
            return

        if header_result is None:
            self._handel_protocol_error(r_addr, ogn_data)
            return
        connecttype, dest_addr, dest_port, header_length = header_result

        if self._is_local:
            server_addr, server_port = self._get_a_server()
        else:
            server_addr, server_port = dest_addr, dest_port

        addrs = self._dns_cache.get(server_addr, None)
        if addrs is None:
            addrs = socket.getaddrinfo(server_addr, server_port, 0,
                                       socket.SOCK_DGRAM, socket.SOL_UDP)
            if not addrs:
                # drop
                return
            else:
                self._dns_cache[server_addr] = addrs

        af, socktype, proto, canonname, sa = addrs[0]
        key = client_key(r_addr, af)
        client = self._cache.get(key, None)
        if not client:
            # TODO async getaddrinfo
            if self._forbidden_iplist:
                if common.to_str(sa[0]) in self._forbidden_iplist:
                    logging.debug('IP %s is in forbidden list, drop' %
                                  common.to_str(sa[0]))
                    # drop
                    return
            client = socket.socket(af, socktype, proto)
            client.setblocking(False)
            self._cache[key] = client
            self._client_fd_to_server_addr[client.fileno()] = r_addr

            self._sockets.add(client.fileno())
            self._eventloop.add(client, eventloop.POLL_IN, self)

            logging.debug('UDP port %5d sockets %d' % (self._listen_port, len(self._sockets)))

            logging.info('UDP data to %s:%d from %s:%d' %
                        (common.to_str(server_addr), server_port,
                            r_addr[0], r_addr[1]))

        if self._is_local:
            data = encrypt.encrypt_all(self._password, self._method, 1, data)
            if not data:
                return
        else:
            data = data[header_length:]
        if not data:
            return
        try:
            #logging.info('UDP handle_server sendto %s:%d %d bytes' % (common.to_str(server_addr), server_port, len(data)))
            client.sendto(data, (server_addr, server_port))
        except IOError as e:
            err = eventloop.errno_from_exception(e)
            if err in (errno.EINPROGRESS, errno.EAGAIN):
                pass
            else:
                shell.print_exception(e)",_1154.py,128,"'IP %s is in forbidden list, drop' % common.to_str(sa[0])","f'IP {common.to_str(sa[0])} is in forbidden list, drop'",1.0
https://github.com/matplotlib/matplotlib/tree/master/lib/matplotlib/backends/backend_ps.py,"def create_hatch(self, hatch):
        sidelen = 72
        if hatch in self._hatches:
            return self._hatches[hatch]
        name = 'H%d' % len(self._hatches)
        linewidth = mpl.rcParams['hatch.linewidth']
        pageheight = self.height * 72
        self._pswriter.write(f""""""\
  << /PatternType 1
     /PaintType 2
     /TilingType 2
     /BBox[0 0 {sidelen:d} {sidelen:d}]
     /XStep {sidelen:d}
     /YStep {sidelen:d}

     /PaintProc {{
        pop
        {linewidth:g} setlinewidth
{self._convert_path(
    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}
        gsave
        fill
        grestore
        stroke
     }} bind
   >>
   matrix
   0 {pageheight:g} translate
   makepattern
   /{name} exch def
"""""")
        self._hatches[hatch] = name
        return name",_1184.py,5,'H%d' % len(self._hatches),f'H{len(self._hatches)}',1.0
https://github.com/machin3io/MACHIN3tools/tree/master/ui/operators/call_pie.py,"def invoke(self, context, event):
        if context.space_data.type == 'VIEW_3D':

            # SHADING PIE

            if self.idname == 'shading_pie':
                engine = context.scene.render.engine
                device = context.scene.cycles.device
                shading = context.space_data.shading

                # sync render engine settings
                if engine != context.scene.M3.render_engine and engine in ['BLENDER_EEVEE', 'CYCLES']:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.render_engine = engine

                # sync cyclces device settings
                if engine == 'CYCLES' and device != context.scene.M3.cycles_device:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.cycles_device = device

                # sync shading.light
                if shading.light != context.scene.M3.shading_light:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.shading_light = shading.light

                    context.scene.M3.avoid_update = True
                    context.scene.M3.use_flat_shadows = shading.show_shadows


                bpy.ops.wm.call_menu_pie(name='MACHIN3_MT_%s' % (self.idname))

            # TOOLS PIE

            elif self.idname == 'tools_pie':
                if context.mode in ['OBJECT', 'EDIT_MESH']:
                    bpy.ops.wm.call_menu_pie(name='MACHIN3_MT_%s' % (self.idname))

                else:
                    return {'PASS_THROUGH'}

        return {'FINISHED'}",_1186.py,30,'MACHIN3_MT_%s' % self.idname,f'MACHIN3_MT_{self.idname}',1.0
https://github.com/machin3io/MACHIN3tools/tree/master/ui/operators/call_pie.py,"def invoke(self, context, event):
        if context.space_data.type == 'VIEW_3D':

            # SHADING PIE

            if self.idname == 'shading_pie':
                engine = context.scene.render.engine
                device = context.scene.cycles.device
                shading = context.space_data.shading

                # sync render engine settings
                if engine != context.scene.M3.render_engine and engine in ['BLENDER_EEVEE', 'CYCLES']:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.render_engine = engine

                # sync cyclces device settings
                if engine == 'CYCLES' and device != context.scene.M3.cycles_device:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.cycles_device = device

                # sync shading.light
                if shading.light != context.scene.M3.shading_light:
                    context.scene.M3.avoid_update = True
                    context.scene.M3.shading_light = shading.light

                    context.scene.M3.avoid_update = True
                    context.scene.M3.use_flat_shadows = shading.show_shadows


                bpy.ops.wm.call_menu_pie(name='MACHIN3_MT_%s' % (self.idname))

            # TOOLS PIE

            elif self.idname == 'tools_pie':
                if context.mode in ['OBJECT', 'EDIT_MESH']:
                    bpy.ops.wm.call_menu_pie(name='MACHIN3_MT_%s' % (self.idname))

                else:
                    return {'PASS_THROUGH'}

        return {'FINISHED'}",_1186.py,36,'MACHIN3_MT_%s' % self.idname,f'MACHIN3_MT_{self.idname}',1.0
https://github.com/WZBSocialScienceCenter/pdftabextract/tree/master/pdftabextract/imgproc.py,"def _load_imgfile(self):  
        """"""Load the image file self.imgfile to self.input_img. Additionally set the image width and height (self.img_w
        and self.img_h)""""""      
        self.input_img = cv2.imread(self.imgfile)
        if self.input_img is None:
            raise IOError(""could not load file '%s'"" % self.imgfile)

        self.img_h, self.img_w = self.input_img.shape[:2]",_1223.py,6,"""could not load file '%s'"" % self.imgfile","f""could not load file '{self.imgfile}'""",1
https://github.com/jookies/jasmin/tree/master/jasmin/routing/Filters.py,"def __init__(self, user):
        Filter.__init__(self, user=user)

        self._repr = '<U (uid=%s)>' % user.uid
        self._str = '%s:\nuid = %s' % (self.__class__.__name__, user.uid)",_1225.py,4,'<U (uid=%s)>' % user.uid,f'<U (uid={user.uid})>',1.0
https://github.com/jookies/jasmin/tree/master/jasmin/routing/Filters.py,"def __init__(self, user):
        Filter.__init__(self, user=user)

        self._repr = '<U (uid=%s)>' % user.uid
        self._str = '%s:\nuid = %s' % (self.__class__.__name__, user.uid)",_1225.py,5,"'%s:\nuid = %s' % (self.__class__.__name__, user.uid)",f'{self.__class__.__name__}:\nuid = {self.__class__.__name__}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,8,'#filter=%s' % state,f'#filter={state}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,10,'&user=%s' % user,f'&user={user}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,12,'&month=%s' % month,f'&month={month}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,14,'#filter=checks&checks=%s' % check,f'#filter=checks&checks={check}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,26,'&sort=%s' % sort,f'&sort={sort}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,28,'#sort=%s' % sort,f'#sort={sort}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,16,'#filter=checks&category=%s' % check_category,f'#filter=checks&category={check_category}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,18,'#search=%s' % urllib.quote_plus(search),f'#search={urllib.quote_plus(search)}',1.0
https://github.com/translate/pootle/tree/master/pootle/core/url_helpers.py,"def get_editor_filter(state=None, check=None, user=None, month=None,
                      sort=None, search=None, sfields=None,
                      check_category=None):
    """"""Return a filter string to be appended to a translation URL.""""""
    filter_string = ''

    if state is not None:
        filter_string = '#filter=%s' % state
        if user is not None:
            filter_string += '&user=%s' % user
        if month is not None:
            filter_string += '&month=%s' % month
    elif check is not None:
        filter_string = '#filter=checks&checks=%s' % check
    elif check_category is not None:
        filter_string = '#filter=checks&category=%s' % check_category
    elif search is not None:
        filter_string = '#search=%s' % urllib.quote_plus(search)
        if sfields is not None:
            if not isinstance(sfields, list):
                sfields = [sfields]
            filter_string += '&sfields=%s' % ','.join(sfields)

    if sort is not None:
        if filter_string:
            filter_string += '&sort=%s' % sort
        else:
            filter_string = '#sort=%s' % sort

    return filter_string",_1227.py,22,"'&sfields=%s' % ','.join(sfields)","f""&sfields={','.join(sfields)}""",1.0
https://github.com/pkkid/python-plexapi/tree/master/plexapi/client.py,"def connect(self, timeout=None):
        """""" Alias of reload as any subsequent requests to this client will be
            made directly to the device even if the object attributes were initially
            populated from a PlexServer.
        """"""
        if not self.key:
            raise Unsupported('Cannot reload an object not built from a URL.')
        self._initpath = self.key
        data = self.query(self.key, timeout=timeout)
        if not data:
            raise NotFound(""Client not found at %s"" % self._baseurl)
        if self._clientIdentifier:
            client = next(
                (
                    x
                    for x in data
                    if x.attrib.get(""machineIdentifier"") == self._clientIdentifier
                ),
                None,
            )
            if client is None:
                raise NotFound(
                    ""Client with identifier %s not found at %s""
                    % (self._clientIdentifier, self._baseurl)
                )
        else:
            client = data[0]
        self._loadData(client)
        return self",_125.py,11,'Client not found at %s' % self._baseurl,f'Client not found at {self._baseurl}',1.0
https://github.com/pkkid/python-plexapi/tree/master/plexapi/client.py,"def connect(self, timeout=None):
        """""" Alias of reload as any subsequent requests to this client will be
            made directly to the device even if the object attributes were initially
            populated from a PlexServer.
        """"""
        if not self.key:
            raise Unsupported('Cannot reload an object not built from a URL.')
        self._initpath = self.key
        data = self.query(self.key, timeout=timeout)
        if not data:
            raise NotFound(""Client not found at %s"" % self._baseurl)
        if self._clientIdentifier:
            client = next(
                (
                    x
                    for x in data
                    if x.attrib.get(""machineIdentifier"") == self._clientIdentifier
                ),
                None,
            )
            if client is None:
                raise NotFound(
                    ""Client with identifier %s not found at %s""
                    % (self._clientIdentifier, self._baseurl)
                )
        else:
            client = data[0]
        self._loadData(client)
        return self",_125.py,23,"'Client with identifier %s not found at %s' % (self._clientIdentifier, self._baseurl)",f'Client with identifier {self._clientIdentifier} not found at {self._clientIdentifier}',1.0
https://github.com/vkbo/novelWriter/tree/master/novelwriter/tools/build.py,"def _updateBuildAge(self):
        """"""Update the build time and the fuzzy age.
        """"""
        if self.buildTime > 0:
            strBuildTime = ""%s (%s)"" % (
                datetime.fromtimestamp(self.buildTime).strftime(""%x %X""),
                fuzzyTime(time() - self.buildTime)
            )
        else:
            strBuildTime = self.tr(""Unknown"")

        self.theTitle.setText(self.tr(""<b>Build Time:</b> {0}"").format(strBuildTime))

        return",_126.py,5,"'%s (%s)' % (datetime.fromtimestamp(self.buildTime).strftime('%x %X'), fuzzyTime(time() - self.buildTime))","f""{datetime.fromtimestamp(self.buildTime).strftime('%x %X')} ({datetime.fromtimestamp(self.buildTime).strftime('%x %X')})""",1.0
https://github.com/ansible/ansible/tree/master/lib/ansible/plugins/filter/mathstuff.py,"def power(x, y):
    try:
        return math.pow(x, y)
    except TypeError as e:
        raise AnsibleFilterTypeError('pow() can only be used on numbers: %s' % to_native(e))",_1310.py,5,'pow() can only be used on numbers: %s' % to_native(e),f'pow() can only be used on numbers: {to_native(e)}',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,6,'background-color: %s;' % number_color[1],f'background-color: {number_color[1]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,14,'background-color: %s;' % number_color[0],f'background-color: {number_color[0]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,23,'background-color: %s;' % number_color[1],f'background-color: {number_color[1]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,31,'background-color: %s;' % number_color[2],f'background-color: {number_color[2]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,39,'background-color: %s;' % number_color[3],f'background-color: {number_color[3]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,47,'background-color: %s;' % number_color[4],f'background-color: {number_color[4]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,55,'background-color: %s;' % number_color[5],f'background-color: {number_color[5]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,63,'background-color: %s;' % number_color[6],f'background-color: {number_color[6]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,71,'background-color: %s;' % number_color[7],f'background-color: {number_color[7]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,79,'background-color: %s;' % number_color[8],f'background-color: {number_color[8]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,86,'background-color: %s;' % number_color[9],f'background-color: {number_color[9]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,98,'background-color: %s;' % number_color[10],f'background-color: {number_color[10]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,107,'background-color: %s;' % number_color[11],f'background-color: {number_color[11]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,116,'background-color: %s;' % number_color[12],f'background-color: {number_color[12]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,125,'background-color: %s;' % number_color[13],f'background-color: {number_color[13]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,134,'background-color: %s;' % number_color[14],f'background-color: {number_color[14]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,143,'background-color: %s;' % number_color[15],f'background-color: {number_color[15]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,152,'background-color: %s;' % number_color[16],f'background-color: {number_color[16]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,161,'background-color: %s;' % number_color[17],f'background-color: {number_color[17]};',1.0
https://github.com/ZPdesu/SEAN/tree/master/ui/ui.py,"def add_label_buttons(self, Form):

        self.color_Button = QtWidgets.QPushButton(Form)
        self.color_Button.setGeometry(QtCore.QRect(int(Lb_x - 1*Lb_row_shift - 60), Lb_y, 60, 60))
        self.color_Button.setObjectName(""labelButton_0"")
        self.color_Button.setStyleSheet(""background-color: %s;"" % number_color[1])



        self.labelButton_0 = QtWidgets.QPushButton(Form)
        self.labelButton_0.setGeometry(QtCore.QRect(Lb_x, Lb_y, Lb_width, Lb_height))
        self.labelButton_0.setObjectName(""labelButton_0"")
        self.labelButton_0.setText(_translate(""Form"", ""background""))
        self.labelButton_0.setStyleSheet(""background-color: %s;"" % number_color[0]+ "" color: black"")
        self.labelButton_0.clicked.connect(partial(Form.switch_labels, 0))



        self.labelButton_1 = QtWidgets.QPushButton(Form)
        self.labelButton_1.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_1.setObjectName(""labelButton_1"")
        self.labelButton_1.setText(_translate(""Form"", ""skin""))
        self.labelButton_1.setStyleSheet(""background-color: %s;"" % number_color[1] + "" color: black"")
        self.labelButton_1.clicked.connect(partial(Form.switch_labels, 1))


        self.labelButton_2 = QtWidgets.QPushButton(Form)
        self.labelButton_2.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_2.setObjectName(""labelButton_2"")
        self.labelButton_2.setText(_translate(""Form"", ""nose""))
        self.labelButton_2.setStyleSheet(""background-color: %s;"" % number_color[2] + "" color: black"")
        self.labelButton_2.clicked.connect(partial(Form.switch_labels, 2))


        self.labelButton_3 = QtWidgets.QPushButton(Form)
        self.labelButton_3.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_3.setObjectName(""labelButton_3"")
        self.labelButton_3.setText(_translate(""Form"", ""eye_g""))
        self.labelButton_3.setStyleSheet(""background-color: %s;"" % number_color[3] + "" color: black"")
        self.labelButton_3.clicked.connect(partial(Form.switch_labels, 3))


        self.labelButton_4 = QtWidgets.QPushButton(Form)
        self.labelButton_4.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_4.setObjectName(""labelButton_4"")
        self.labelButton_4.setText(_translate(""Form"", ""l_eye""))
        self.labelButton_4.setStyleSheet(""background-color: %s;"" % number_color[4] + "" color: black"")
        self.labelButton_4.clicked.connect(partial(Form.switch_labels, 4))


        self.labelButton_5 = QtWidgets.QPushButton(Form)
        self.labelButton_5.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_5.setObjectName(""labelButton_5"")
        self.labelButton_5.setText(_translate(""Form"", ""r_eye""))
        self.labelButton_5.setStyleSheet(""background-color: %s;"" % number_color[5] + "" color: black"")
        self.labelButton_5.clicked.connect(partial(Form.switch_labels, 5))


        self.labelButton_6 = QtWidgets.QPushButton(Form)
        self.labelButton_6.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_6.setObjectName(""labelButton_6"")
        self.labelButton_6.setText(_translate(""Form"", ""l_brow""))
        self.labelButton_6.setStyleSheet(""background-color: %s;"" % number_color[6] + "" color: black"")
        self.labelButton_6.clicked.connect(partial(Form.switch_labels, 6))


        self.labelButton_7 = QtWidgets.QPushButton(Form)
        self.labelButton_7.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_7.setObjectName(""labelButton_7"")
        self.labelButton_7.setText(_translate(""Form"", ""r_brow""))
        self.labelButton_7.setStyleSheet(""background-color: %s;"" % number_color[7] + "" color: black"")
        self.labelButton_7.clicked.connect(partial(Form.switch_labels, 7))


        self.labelButton_8 = QtWidgets.QPushButton(Form)
        self.labelButton_8.setGeometry(QtCore.QRect(Lb_x + 8*Lb_row_shift + 8*Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_8.setObjectName(""labelButton_8"")
        self.labelButton_8.setText(_translate(""Form"", ""l_ear""))
        self.labelButton_8.setStyleSheet(""background-color: %s;"" % number_color[8] + "" color: black"")
        self.labelButton_8.clicked.connect(partial(Form.switch_labels, 8))

        self.labelButton_9 = QtWidgets.QPushButton(Form)
        self.labelButton_9.setGeometry(QtCore.QRect(Lb_x + 9 * Lb_row_shift + 9 * Lb_width, Lb_y, Lb_width, Lb_height))
        self.labelButton_9.setObjectName(""labelButton_9"")
        self.labelButton_9.setText(_translate(""Form"", ""r_ear""))
        self.labelButton_9.setStyleSheet(""background-color: %s;"" % number_color[9] + "" color: black"")
        self.labelButton_9.clicked.connect(partial(Form.switch_labels, 9))


        # Second Row


        self.labelButton_10 = QtWidgets.QPushButton(Form)
        self.labelButton_10.setGeometry(QtCore.QRect(Lb_x,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_10.setObjectName(""labelButton_10"")
        self.labelButton_10.setText(_translate(""Form"", ""mouth""))
        self.labelButton_10.setStyleSheet(""background-color: %s;"" % number_color[10] + "" color: black"")
        self.labelButton_10.clicked.connect(partial(Form.switch_labels, 10))


        self.labelButton_11 = QtWidgets.QPushButton(Form)
        self.labelButton_11.setGeometry(QtCore.QRect(Lb_x + 1*Lb_row_shift + 1*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_11.setObjectName(""labelButton_11"")
        self.labelButton_11.setText(_translate(""Form"", ""u_lip""))
        self.labelButton_11.setStyleSheet(""background-color: %s;"" % number_color[11] + "" color: black"")
        self.labelButton_11.clicked.connect(partial(Form.switch_labels, 11))


        self.labelButton_12 = QtWidgets.QPushButton(Form)
        self.labelButton_12.setGeometry(QtCore.QRect(Lb_x + 2*Lb_row_shift + 2*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_12.setObjectName(""labelButton_12"")
        self.labelButton_12.setText(_translate(""Form"", ""l_lip""))
        self.labelButton_12.setStyleSheet(""background-color: %s;"" % number_color[12] + "" color: black"")
        self.labelButton_12.clicked.connect(partial(Form.switch_labels, 12))


        self.labelButton_13 = QtWidgets.QPushButton(Form)
        self.labelButton_13.setGeometry(QtCore.QRect(Lb_x + 3*Lb_row_shift + 3*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_13.setObjectName(""labelButton_13"")
        self.labelButton_13.setText(_translate(""Form"", ""hair""))
        self.labelButton_13.setStyleSheet(""background-color: %s;"" % number_color[13] + "" color: black"")
        self.labelButton_13.clicked.connect(partial(Form.switch_labels, 13))


        self.labelButton_14 = QtWidgets.QPushButton(Form)
        self.labelButton_14.setGeometry(QtCore.QRect(Lb_x + 4*Lb_row_shift + 4*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_14.setObjectName(""labelButton_14"")
        self.labelButton_14.setText(_translate(""Form"", ""hat""))
        self.labelButton_14.setStyleSheet(""background-color: %s;"" % number_color[14] + "" color: black"")
        self.labelButton_14.clicked.connect(partial(Form.switch_labels, 14))


        self.labelButton_15 = QtWidgets.QPushButton(Form)
        self.labelButton_15.setGeometry(QtCore.QRect(Lb_x + 5*Lb_row_shift + 5*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_15.setObjectName(""labelButton_15"")
        self.labelButton_15.setText(_translate(""Form"", ""ear_r""))
        self.labelButton_15.setStyleSheet(""background-color: %s;"" % number_color[15] + "" color: black"")
        self.labelButton_15.clicked.connect(partial(Form.switch_labels, 15))


        self.labelButton_16 = QtWidgets.QPushButton(Form)
        self.labelButton_16.setGeometry(QtCore.QRect(Lb_x + 6*Lb_row_shift + 6*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_16.setObjectName(""labelButton_16"")
        self.labelButton_16.setText(_translate(""Form"", ""neck_l""))
        self.labelButton_16.setStyleSheet(""background-color: %s;"" % number_color[16] + "" color: black"")
        self.labelButton_16.clicked.connect(partial(Form.switch_labels, 16))


        self.labelButton_17 = QtWidgets.QPushButton(Form)
        self.labelButton_17.setGeometry(QtCore.QRect(Lb_x + 7*Lb_row_shift + 7*Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_17.setObjectName(""labelButton_17"")
        self.labelButton_17.setText(_translate(""Form"", ""neck""))
        self.labelButton_17.setStyleSheet(""background-color: %s;"" % number_color[17] + "" color: black"")
        self.labelButton_17.clicked.connect(partial(Form.switch_labels, 17))

        self.labelButton_18 = QtWidgets.QPushButton(Form)
        self.labelButton_18.setGeometry(QtCore.QRect(Lb_x + 8 * Lb_row_shift + 8 * Lb_width,
                                                     Lb_y + Lb_height + Lb_col_shift, Lb_width, Lb_height))
        self.labelButton_18.setObjectName(""labelButton_18"")
        self.labelButton_18.setText(_translate(""Form"", ""cloth""))
        self.labelButton_18.setStyleSheet(""background-color: %s;"" % number_color[18] + "" color: black"")
        self.labelButton_18.clicked.connect(partial(Form.switch_labels, 18))",_1316.py,169,'background-color: %s;' % number_color[18],f'background-color: {number_color[18]};',1.0
https://github.com/PaddlePaddle/PaddleHub/tree/master/modules/text/text_generation/ernie_gen_couplet/module.py,"def run_cmd(self, argvs):
        """"""
        Run as a command
        """"""
        self.parser = argparse.ArgumentParser(
            description='Run the %s module.' % self.name,
            prog='hub run %s' % self.name,
            usage='%(prog)s',
            add_help=True)

        self.arg_input_group = self.parser.add_argument_group(title=""Input options"", description=""Input data. Required"")
        self.arg_config_group = self.parser.add_argument_group(
            title=""Config options"", description=""Run configuration for controlling module behavior, optional."")

        self.add_module_config_arg()
        self.add_module_input_arg()

        args = self.parser.parse_args(argvs)

        try:
            input_data = self.check_input_data(args)
        except DataFormatError and RuntimeError:
            self.parser.print_help()
            return None

        results = self.generate(texts=input_data, use_gpu=args.use_gpu, beam_width=args.beam_width)

        return results",_1318.py,6,'Run the %s module.' % self.name,f'Run the {self.name} module.',1.0
https://github.com/PaddlePaddle/PaddleHub/tree/master/modules/text/text_generation/ernie_gen_couplet/module.py,"def run_cmd(self, argvs):
        """"""
        Run as a command
        """"""
        self.parser = argparse.ArgumentParser(
            description='Run the %s module.' % self.name,
            prog='hub run %s' % self.name,
            usage='%(prog)s',
            add_help=True)

        self.arg_input_group = self.parser.add_argument_group(title=""Input options"", description=""Input data. Required"")
        self.arg_config_group = self.parser.add_argument_group(
            title=""Config options"", description=""Run configuration for controlling module behavior, optional."")

        self.add_module_config_arg()
        self.add_module_input_arg()

        args = self.parser.parse_args(argvs)

        try:
            input_data = self.check_input_data(args)
        except DataFormatError and RuntimeError:
            self.parser.print_help()
            return None

        results = self.generate(texts=input_data, use_gpu=args.use_gpu, beam_width=args.beam_width)

        return results",_1318.py,7,'hub run %s' % self.name,f'hub run {self.name}',1.0
https://github.com/openstack/swift/tree/master/swift/common/request_helpers.py,"def _byte_counting_iter(self):
        # Checks that we give the client the right number of bytes. Raises
        # SegmentError if the number of bytes is wrong.
        bytes_left = self.response_body_length

        for seg_name, chunk in self._requests_to_bytes_iter():
            if bytes_left is None:
                yield chunk
            elif bytes_left >= len(chunk):
                yield chunk
                bytes_left -= len(chunk)
            else:
                yield chunk[:bytes_left]
                bytes_left -= len(chunk)
                raise SegmentError(
                    'Too many bytes for %(name)s; truncating in '
                    '%(seg)s with %(left)d bytes left' %
                    {'name': self.name, 'seg': seg_name,
                     'left': -bytes_left})

        if bytes_left:
            raise SegmentError('Expected another %d bytes for %s; '
                               'closing connection' % (bytes_left, self.name))",_1320.py,16,"Too many bytes for %(name)s; truncating in %(seg)s with %(left)d bytes left' % {'name': self.name, 'seg': seg_name, 'left': -bytes_left}","f""Too many bytes for {self.name}; truncating in {seg_name} with {-bytes_left bytes} left""",1
https://github.com/openstack/swift/tree/master/swift/common/request_helpers.py,"def _byte_counting_iter(self):
        # Checks that we give the client the right number of bytes. Raises
        # SegmentError if the number of bytes is wrong.
        bytes_left = self.response_body_length

        for seg_name, chunk in self._requests_to_bytes_iter():
            if bytes_left is None:
                yield chunk
            elif bytes_left >= len(chunk):
                yield chunk
                bytes_left -= len(chunk)
            else:
                yield chunk[:bytes_left]
                bytes_left -= len(chunk)
                raise SegmentError(
                    'Too many bytes for %(name)s; truncating in '
                    '%(seg)s with %(left)d bytes left' %
                    {'name': self.name, 'seg': seg_name,
                     'left': -bytes_left})

        if bytes_left:
            raise SegmentError('Expected another %d bytes for %s; '
                               'closing connection' % (bytes_left, self.name))",_1320.py,22,"'Expected another %d bytes for %s; closing connection' % (bytes_left, self.name)",f'Expected another {bytes_left} bytes for {self.name}; closing connection',1.0
https://github.com/nesdis/djongo/tree/master/tests/django_tests/tests/v21/tests/view_tests/tests/test_static.py,"def test_index_custom_template(self):
        response = self.client.get('/%s/' % self.prefix)
        self.assertEqual(response.content, b'Test index')",_1322.py,2,'/%s/' % self.prefix,f'/{self.prefix}/',1.0
https://github.com/sdispater/orator/tree/master/orator/schema/grammars/mysql_grammar.py,"def _type_double(self, column):
        if column.total and column.places:
            return ""DOUBLE(%s, %s)"" % (column.total, column.places)

        return ""DOUBLE""",_1334.py,3,"'DOUBLE(%s, %s)' % (column.total, column.places)","f'DOUBLE({column.total}, {column.total})'",1.0
https://github.com/kubeflow-kale/kale/tree/master/backend/kale/common/utils.py,"def rm_r(path, ignore_missing=True, silent=False):
    """"""Remove a file or directory.

    Similar to rm -r. If the path does not exist and ignore_missing is False,
    OSError is raised, otherwise it is ignored.
    If silent is True, nothing is raised.
    """"""
    def onerror(function, path, excinfo):
        # Function to handle ENOENT in shutil.rmtree()
        e = excinfo[1]
        if (ignore_missing and isinstance(e, OSError)
                and e.errno == errno.ENOENT):
            return
        raise e

    log.info(""Removing path `%s'"", path)

    try:
        if os.path.isfile(path) or os.path.islink(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path, onerror=onerror)
        elif os.path.exists(path) and not silent:
            raise RuntimeError(""Failed to remove path `%s': Path exists but is""
                               "" not a file nor a directory"" % path)
        else:
            # The path does not exists, raise the appropriate exception and let
            # the exception handler handle it (i.e., check ignore_missing etc.)
            raise OSError(errno.ENOENT, ""No such file or directory"", path)
    except OSError as e:
        if silent:
            log.debug(""Path `%s' does not exist, skipping removing it"", path)
            return
        if (not ignore_missing) or (e.errno != errno.ENOENT):
            log.error(""Failed to remove path `%s' (errno: %s): %s"",
                      path, e.errno, e)
            raise",_1364.py,24,"""Failed to remove path `%s': Path exists but is not a file nor a directory"" % path","f""Failed to remove path `{path}': Path exists but is not a file nor a directory""",1.0
https://github.com/QUANTAXIS/QUANTAXIS/tree/master/QUANTAXIS/QAPubSub/consumer.py,"def callback(self, chan, method_frame, _header_frame, body, userdata=None):
        print(1)
        print("" [x] %r"" % body)",_1370.py,3,' [x] %r' % body,f' [x] {body}',1.0
https://github.com/influxdata/influxdb-python/tree/master/influxdb/dataframe_client.py,"def __init__(self, *a, **kw):
            """"""Initialize the default DataFrameClient.""""""
            super(DataFrameClient, self).__init__()
            raise ImportError(""DataFrameClient requires Pandas ""
                              ""which couldn't be imported: %s"" % self.err)",_1372.py,4,"""DataFrameClient requires Pandas which couldn't be imported: %s"" % self.err","f""DataFrameClient requires Pandas which couldn't be imported: {self.err}""",1.0
https://github.com/NVIDIA/flownet2-pytorch/tree/master//datasets.py,"def __init__(self, args, is_cropped = False, root = '', dstype = 'clean', replicates = 1):
        self.args = args
        self.is_cropped = is_cropped
        self.crop_size = args.crop_size
        self.render_size = args.inference_size
        self.replicates = replicates

        flow_root = join(root, 'flow')
        image_root = join(root, dstype)

        file_list = sorted(glob(join(flow_root, '*/*.flo')))

        self.flow_list = []
        self.image_list = []

        for file in file_list:
            if 'test' in file:
                # print file
                continue

            fbase = file[len(flow_root)+1:]
            fprefix = fbase[:-8]
            fnum = int(fbase[-8:-4])

            img1 = join(image_root, fprefix + ""%04d""%(fnum+0) + '.png')
            img2 = join(image_root, fprefix + ""%04d""%(fnum+1) + '.png')

            if not isfile(img1) or not isfile(img2) or not isfile(file):
                continue

            self.image_list += [[img1, img2]]
            self.flow_list += [file]

        self.size = len(self.image_list)

        self.frame_size = frame_utils.read_gen(self.image_list[0][0]).shape

        if (self.render_size[0] < 0) or (self.render_size[1] < 0) or (self.frame_size[0]%64) or (self.frame_size[1]%64):
            self.render_size[0] = ( (self.frame_size[0])//64 ) * 64
            self.render_size[1] = ( (self.frame_size[1])//64 ) * 64

        args.inference_size = self.render_size

        assert (len(self.image_list) == len(self.flow_list))",_1412.py,25,'%04d' % (fnum + 0),f'{fnum + 0}',1.0
https://github.com/NVIDIA/flownet2-pytorch/tree/master//datasets.py,"def __init__(self, args, is_cropped = False, root = '', dstype = 'clean', replicates = 1):
        self.args = args
        self.is_cropped = is_cropped
        self.crop_size = args.crop_size
        self.render_size = args.inference_size
        self.replicates = replicates

        flow_root = join(root, 'flow')
        image_root = join(root, dstype)

        file_list = sorted(glob(join(flow_root, '*/*.flo')))

        self.flow_list = []
        self.image_list = []

        for file in file_list:
            if 'test' in file:
                # print file
                continue

            fbase = file[len(flow_root)+1:]
            fprefix = fbase[:-8]
            fnum = int(fbase[-8:-4])

            img1 = join(image_root, fprefix + ""%04d""%(fnum+0) + '.png')
            img2 = join(image_root, fprefix + ""%04d""%(fnum+1) + '.png')

            if not isfile(img1) or not isfile(img2) or not isfile(file):
                continue

            self.image_list += [[img1, img2]]
            self.flow_list += [file]

        self.size = len(self.image_list)

        self.frame_size = frame_utils.read_gen(self.image_list[0][0]).shape

        if (self.render_size[0] < 0) or (self.render_size[1] < 0) or (self.frame_size[0]%64) or (self.frame_size[1]%64):
            self.render_size[0] = ( (self.frame_size[0])//64 ) * 64
            self.render_size[1] = ( (self.frame_size[1])//64 ) * 64

        args.inference_size = self.render_size

        assert (len(self.image_list) == len(self.flow_list))",_1412.py,26,'%04d' % (fnum + 1),f'{fnum + 1}',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,32,"' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))",f' {field.name} = {field.name};\n',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,35,"'%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))",f'{labels[field.label]} {labels[field.label]} {labels[field.label]} = {labels[field.label]};\n',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,37,"'%s group %s = %d ' % (labels[field.label], type_, field.number)",f'{labels[field.label]} group {labels[field.label]} = {field.number} ',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,46,'_oneof_%d' % field.oneof_index,f'_oneof_{field.oneof_index}',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,47,'_oneof_%d' % field.oneof_index,f'_oneof_{field.oneof_index}',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,7,'default = %s' % fmt_value(field.default_value),f'default = {fmt_value(field.default_value)}',1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,9,"'default = ""%s""' % field.default_value","f'default = ""{field.default_value}""'",1.0
https://github.com/marin-m/pbtk/tree/master/utils/descpb_to_proto.py,"def fmt_field(field, scopes, blocks, syntax, extend=False):
    type_ = types[field.type]
    
    default = ''
    if field.default_value:
        if field.type == field.TYPE_STRING:
            default = ['default = %s' % fmt_value(field.default_value)]
        elif field.type == field.TYPE_BYTES:
            default = ['default = ""%s""' % field.default_value]
        else:
            # Guess whether it ought to be more readable as base 10 or 16,
            # based on the presence of repeated digits:
            
            if ('int' in type_ or 'fixed' in type_) and \
               int(field.default_value) >= 0x10000 and \
               not any(len(list(i)) > 3 for _, i in groupby(str(field.default_value))):
                
                field.default_value = hex(int(field.default_value))
            
            default = ['default = %s' % field.default_value]
    
    out = ''
    if field.type_name:
        type_ = min_name(field.type_name, scopes)
        short_type = type_.split('.')[-1]
        
        if short_type in blocks and ((not extend and not field.HasField('oneof_index')) or \
                                      blocks[short_type].startswith(' map<')):
            out += blocks.pop(short_type)[1:]
    
    if out.startswith('map<'):
        line = out + ' %s = %s;\n' % (field.name, fmt_value(field.number, field.options, optarr=default))
        out = ''
    elif field.type != field.TYPE_GROUP:
        line = '%s %s %s = %s;\n' % (labels[field.label], type_, field.name, fmt_value(field.number, field.options, optarr=default))
    else:
        line = '%s group %s = %d ' % (labels[field.label], type_, field.number)
        out = out.split(' ', 2)[-1]
    
    if field.HasField('oneof_index') or (syntax == 'proto3' and line.startswith('optional')):
        line = line.split(' ', 1)[-1]
    if out:
        line = '\n' + line
    
    if field.HasField('oneof_index'):
        blocks.setdefault('_oneof_%d' % field.oneof_index, '')
        blocks['_oneof_%d' % field.oneof_index] += line + out
        return ''
    else:
        return line + out",_1415.py,20,'default = %s' % field.default_value,f'default = {field.default_value}',1.0
https://github.com/pretix/pretix/tree/master/src/tests/presale/test_cart.py,"def test_add_seat_blocked(self):
        self.seat_a1.blocked = True
        self.seat_a1.save()
        self.client.post('/%s/%s/cart/add' % (self.orga.slug, self.event.slug), {
            'seat_%d' % self.ticket.id: self.seat_a1.seat_guid,
        }, follow=True)
        with scopes_disabled():
            objs = list(CartPosition.objects.filter(cart_id=self.session_key, event=self.event))
            self.assertEqual(len(objs), 0)",_1421.py,4,"'/%s/%s/cart/add' % (self.orga.slug, self.event.slug)",f'/{self.orga.slug}/{self.orga.slug}/cart/add',1.0
https://github.com/pretix/pretix/tree/master/src/tests/presale/test_cart.py,"def test_add_seat_blocked(self):
        self.seat_a1.blocked = True
        self.seat_a1.save()
        self.client.post('/%s/%s/cart/add' % (self.orga.slug, self.event.slug), {
            'seat_%d' % self.ticket.id: self.seat_a1.seat_guid,
        }, follow=True)
        with scopes_disabled():
            objs = list(CartPosition.objects.filter(cart_id=self.session_key, event=self.event))
            self.assertEqual(len(objs), 0)",_1421.py,5,'seat_%d' % self.ticket.id,f'seat_{self.ticket.id}',1.0
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,16,"out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text, ui_rate, ui_size, ui_time, ui_end)","'%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text, ui_rate, ui_size, ui_time, ui_end)",1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,31,"out = '\r%-*.*s%s%s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text, ui_pc, ui_bar, ui_rate, ui_size, ui_time, ui_end)",f'{self.text:<{tl.rest()}}{ui_pc}{ui_bar}{ui_rate}{ui_size}{ui_time}{ui_end}',1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,13,"  %s' % format_time(etime, use_hours)","f'  {format_time(etime, use_hours)}'",1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,15, %5sB/s' % ave_dl,f'{ave_dl:5}B/s',1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,23,'  %s' % frtime,f'  {frtime}',1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,26,' %2i%%' % (frac * 100),f'{frac * 100:2}%',1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,27,' %5sB/s' % ave_dl,f'{ave_dl}B/s',1
https://github.com/virt-manager/virt-manager/tree/master/virtinst/_progresspriv.py,"def _do_update(self, amount_read):
        etime = self.re.elapsed_time()
        fread = format_number(amount_read)

        ave_dl = format_number(self.re.average_rate())

        # Include text + ui_rate in minimal
        tl = TerminalLine(8, 8 + 1 + 8)
        # For big screens, make it more readable.
        use_hours = bool(tl.llen > 80)
        ui_size = tl.add(' | %5sB' % fread)
        if self.size is None:
            ui_time = tl.add('  %s' % format_time(etime, use_hours))
            ui_end = tl.add(' ' * 5)
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            out = '%-*.*s%s%s%s%s\r' % (tl.rest(), tl.rest(), self.text,
                                        ui_rate, ui_size, ui_time, ui_end)
        else:
            rtime = self.re.remaining_time()
            frtime = format_time(rtime, use_hours)
            frac = self.re.fraction_read()

            ui_time = tl.add('  %s' % frtime)
            ui_end = tl.add(' ETA ')

            ui_pc = tl.add(' %2i%%' % (frac * 100))
            ui_rate = tl.add(' %5sB/s' % ave_dl)
            # Make text grow a bit before we start growing the bar too
            blen = 4 + tl.rest_split(8 + 8 + 4)
            ui_bar = _term_add_bar(tl, blen, frac)
            out = '\r%-*.*s%s%s%s%s%s%s\r' % (
                tl.rest(), tl.rest(), self.text,
                ui_pc, ui_bar,
                ui_rate, ui_size, ui_time, ui_end
            )

        self.output.write(out)
        self.output.flush()",_1433.py,11,' | %5sB' % fread,f' | {fread:5s}B',1.0
https://github.com/openstack/keystone/tree/master/keystone/tests/protection/v3/test_access_rules.py,"def test_user_cannot_list_access_rules_for_other_users(self):
        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)
        user = PROVIDERS.identity_api.create_user(user)
        project = unit.new_project_ref(
            domain_id=CONF.identity.default_domain_id
        )
        project = PROVIDERS.resource_api.create_project(project['id'], project)
        PROVIDERS.assignment_api.create_grant(
            self.bootstrapper.member_role_id, user_id=user['id'],
            project_id=project['id']
        )
        app_cred = {
            'id': uuid.uuid4().hex,
            'name': uuid.uuid4().hex,
            'user_id': user['id'],
            'project_id': project['id'],
            'secret': uuid.uuid4().hex,
            'access_rules': [{
                'id': uuid.uuid4().hex,
                'service': uuid.uuid4().hex,
                'path': uuid.uuid4().hex,
                'method': uuid.uuid4().hex[16:]
            }]
        }
        PROVIDERS.application_credential_api.create_application_credential(
            app_cred)

        with self.test_client() as c:
            path = '/v3/users/%s/access_rules' % user['id']
            c.get(path, headers=self.headers,
                  expected_status_code=http.client.FORBIDDEN)",_1445.py,29,'/v3/users/%s/access_rules' % user['id'],"f""/v3/users/{user['id']}/access_rules""",1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,131,"%s term %s%s {' % (term_prefix, self.term.name, '-' + suffix if duplicate_term else '')","f'{term_prefix} {self.term.name}{""-"" + suffix if duplicate_term else """"}'
",1
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,23,'Owner: %s' % self.term.owner,f'Owner: {self.term.owner}',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,143,'%s' % comment,f'{comment}',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,152,'%s;' % saddr,f'{saddr};',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,158,'%s' % comment,f'{comment}',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,167,'%s except;' % ex,f'{ex} except;',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,176,'%s' % comment,f'{comment}',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,185,'%s;' % daddr,f'{daddr};',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,191,'%s' % comment,f'{comment}',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,200,'%s except;' % ex,f'{ex} except;',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,146,'%s;' % saddr2,f'{saddr2};',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,161,'%s except;' % ex2,f'{ex2} except;',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,179,'%s;' % daddr2,f'{daddr2};',1.0
https://github.com/google/capirca/tree/master/capirca/lib/junipermsmpc.py,"def __str__(self):
    # Verify platform specific terms. Skip whole term if platform does not
    # match.
    if self.term.platform:
      if self._PLATFORM not in self.term.platform:
        return ''
    if self.term.platform_exclude:
      if self._PLATFORM in self.term.platform_exclude:
        return ''

    if self.enable_dsmo:
      raise NotImplementedError('enable_dsmo not implemented for msmpc')

    ret_str = juniper.Config(indent=self._DEFAULT_INDENT)

    # COMMENTS
    # this deals just fine with multi line comments, but we could probably
    # output them a little cleaner; do things like make sure the
    # len(output) < 80, etc. Note, if 'noverbose' is set for the filter, skip
    # all comment processing.
    if not self.noverbose:
      if self.term.owner:
        self.term.comment.append('Owner: %s' % self.term.owner)
      if self.term.comment:
        ret_str.Append('/*')
        for comment in self.term.comment:
          for line in comment.split('\n'):
            ret_str.Append('** ' + line)
        ret_str.Append('*/')

    # Term verbatim output - this will skip over normal term creation
    # code.  Warning generated from policy.py if appropriate.
    if self.term.verbatim:
      for next_term in self.term.verbatim:
        if next_term[0] == self._PLATFORM:
          ret_str.Append(str(next_term[1]), verbatim=True)
      return str(ret_str)

    # Determine whether there are any match conditions for the term.
    has_match_criteria = (
        self.term.address or self.term.dscp_except or self.term.dscp_match or
        self.term.destination_address or self.term.destination_port or
        self.term.destination_prefix or self.term.destination_prefix_except or
        self.term.encapsulate or self.term.ether_type or
        self.term.flexible_match_range or self.term.forwarding_class or
        self.term.forwarding_class_except or self.term.fragment_offset or
        self.term.hop_limit or self.term.next_ip or self.term.port or
        self.term.precedence or self.term.protocol or
        self.term.protocol_except or self.term.source_address or
        self.term.source_port or self.term.source_prefix or
        self.term.source_prefix_except or self.term.traffic_type or
        self.term.ttl)

    suffixes = []
    duplicate_term = False
    has_icmp = 'icmp' in self.term.protocol
    has_icmpv6 = 'icmpv6' in self.term.protocol
    has_v4_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet'))
    has_v6_ip = self.term.GetAddressOfVersion(
        'source_address',
        self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
            'source_address_exclude',
            self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                'destination_address',
                self.AF_MAP.get('inet6')) or self.term.GetAddressOfVersion(
                    'destination_address_exclude', self.AF_MAP.get('inet6'))

    if self.term_type == 'mixed':
      if not (has_v4_ip or has_v6_ip):
        suffixes = ['inet']
      elif not has_v6_ip:
        suffixes = ['inet']
      elif not has_v4_ip:
        suffixes = ['inet6']
      else:
        suffixes = ['inet', 'inet6']
        duplicate_term = True
    if not suffixes and self.term_type in ['inet', 'inet6']:
      suffixes = [self.term_type]

    for suffix in suffixes:
      if self.term_type == 'mixed' and (not (has_icmp and has_icmpv6)) and (
          has_v4_ip and has_v6_ip):
        if (has_icmp and suffix != 'inet') or (has_icmpv6 and
                                               suffix != 'inet6'):
          continue
      source_address = self.term.GetAddressOfVersion('source_address',
                                                     self.AF_MAP.get(suffix))
      source_address_exclude = self.term.GetAddressOfVersion(
          'source_address_exclude', self.AF_MAP.get(suffix))
      source_address, source_address_exclude = self._MinimizePrefixes(
          source_address, source_address_exclude)
      destination_address = self.term.GetAddressOfVersion(
          'destination_address', self.AF_MAP.get(suffix))
      destination_address_exclude = self.term.GetAddressOfVersion(
          'destination_address_exclude', self.AF_MAP.get(suffix))
      destination_address, destination_address_exclude = self._MinimizePrefixes(
          destination_address, destination_address_exclude)
      if ((not source_address) and self.term.GetAddressOfVersion(
          'source_address', self.AF_MAP.get('mixed')) and
          not source_address_exclude) or (
              (not destination_address) and self.term.GetAddressOfVersion(
                  'destination_address', self.AF_MAP.get('mixed')) and
              not destination_address_exclude):
        continue
      if ((has_icmpv6 and not has_icmp and suffix == 'inet') or
          (has_icmp and not has_icmpv6 and
           suffix == 'inet6')) and self.term_type != 'mixed':
        logging.debug(
            self.NO_AF_LOG_PROTO.substitute(
                term=self.term.name,
                proto=', '.join(self.term.protocol),
                af=suffix))
        return ''

      # NAME
      # if the term is inactive we have to set the prefix
      if self.term.inactive:
        term_prefix = 'inactive:'
      else:
        term_prefix = ''

      ret_str.Append(
          '%s term %s%s {' %
          (term_prefix, self.term.name, '-' + suffix if duplicate_term else ''))

      # We only need a ""from {"" clause if there are any conditions to match.
      if has_match_criteria:
        ret_str.Append('from {')
        # SOURCE ADDRESS
        if source_address or source_address_exclude:
          ret_str.Append('source-address {')
          if source_address:
            for saddr in source_address:
              for comment in self._Comment(saddr):
                ret_str.Append('%s' % comment)
              if saddr.version == 6 and 0 < saddr.prefixlen < 16:
                for saddr2 in saddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % saddr2)
              else:
                if saddr == nacaddr.IPv6('0::0/0'):
                  saddr = 'any-ipv6'
                elif saddr == nacaddr.IPv4('0.0.0.0/0'):
                  saddr = 'any-ipv4'
                ret_str.Append('%s;' % saddr)

          # SOURCE ADDRESS EXCLUDE
          if source_address_exclude:
            for ex in source_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # source-address {...}

        # DESTINATION ADDRESS
        if destination_address or destination_address_exclude:
          ret_str.Append('destination-address {')
          if destination_address:
            for daddr in destination_address:
              for comment in self._Comment(daddr):
                ret_str.Append('%s' % comment)
              if daddr.version == 6 and 0 < daddr.prefixlen < 16:
                for daddr2 in daddr.subnets(new_prefix=16):
                  ret_str.Append('%s;' % daddr2)
              else:
                if daddr == nacaddr.IPv6('0::0/0'):
                  daddr = 'any-ipv6'
                elif daddr == nacaddr.IPv4('0.0.0.0/0'):
                  daddr = 'any-ipv4'
                ret_str.Append('%s;' % daddr)

          # DESTINATION ADDRESS EXCLUDE
          if destination_address_exclude:
            for ex in destination_address_exclude:
              for comment in self._Comment(ex):
                ret_str.Append('%s' % comment)
              if ex.version == 6 and 0 < ex.prefixlen < 16:
                for ex2 in ex.subnets(new_prefix=16):
                  ret_str.Append('%s except;' % ex2)
              else:
                if ex == nacaddr.IPv6('0::0/0'):
                  ex = 'any-ipv6'
                elif ex == nacaddr.IPv4('0.0.0.0/0'):
                  ex = 'any-ipv4'
                ret_str.Append('%s except;' % ex)
          ret_str.Append('}')  # destination-address {...}

        # source prefix <except> list
        if self.term.source_prefix or self.term.source_prefix_except:
          for pfx in self.term.source_prefix:
            ret_str.Append('source-prefix-list ' + pfx + ';')
          for epfx in self.term.source_prefix_except:
            ret_str.Append('source-prefix-list ' + epfx + ' except;')

        # destination prefix <except> list
        if self.term.destination_prefix or self.term.destination_prefix_except:
          for pfx in self.term.destination_prefix:
            ret_str.Append('destination-prefix-list ' + pfx + ';')
          for epfx in self.term.destination_prefix_except:
            ret_str.Append('destination-prefix-list ' + epfx + ' except;')

        # APPLICATION
        if (self.term.source_port or self.term.destination_port or
            self.term.icmp_type or self.term.protocol):
          if hasattr(self.term, 'replacement_application_name'):
            ret_str.Append('application-sets ' +
                           self.term.replacement_application_name + '-app;')
          else:
            ret_str.Append('application-sets ' +
                           self.filter_name[:((MAX_IDENTIFIER_LEN) // 2)] +
                           self.term.name[-((MAX_IDENTIFIER_LEN) // 2):] +
                           '-app;')
        ret_str.Append('}')  # from {...}

      ret_str.Append('then {')
      # ACTION
      for action in self.term.action:
        ret_str.Append(self._ACTIONS.get(str(action)) + ';')
      if self.term.logging and 'disable' not in [
          x.value for x in self.term.logging
      ]:
        ret_str.Append('syslog;')
      ret_str.Append('}')  # then {...}
      ret_str.Append('}')  # term {...}
    return str(ret_str)",_147.py,194,'%s except;' % ex2,f'{ex2} except;',1.0
https://github.com/google/clusterfuzz/tree/master/src/clusterfuzz/_internal/build_management/build_manager.py,"def _set_random_fuzz_target_for_fuzzing_if_needed(fuzz_targets, target_weights):
  """"""Sets a random fuzz target for fuzzing.""""""
  fuzz_target = environment.get_value('FUZZ_TARGET')
  if fuzz_target:
    logs.log('Use previously picked fuzz target %s for fuzzing.' % fuzz_target)
    return fuzz_target

  if not environment.is_engine_fuzzer_job():
    return None

  fuzz_targets = list(fuzz_targets)
  if not fuzz_targets:
    logs.log_error('No fuzz targets found. Unable to pick random one.')
    return None

  environment.set_value('FUZZ_TARGET_COUNT', len(fuzz_targets))

  fuzz_target = fuzzer_selection.select_fuzz_target(fuzz_targets,
                                                    target_weights)
  environment.set_value('FUZZ_TARGET', fuzz_target)
  logs.log('Picked fuzz target %s for fuzzing.' % fuzz_target)

  return fuzz_target",_1471.py,21,'Picked fuzz target %s for fuzzing.' % fuzz_target,f'Picked fuzz target {fuzz_target} for fuzzing.',1.0
https://github.com/google/clusterfuzz/tree/master/src/clusterfuzz/_internal/build_management/build_manager.py,"def _set_random_fuzz_target_for_fuzzing_if_needed(fuzz_targets, target_weights):
  """"""Sets a random fuzz target for fuzzing.""""""
  fuzz_target = environment.get_value('FUZZ_TARGET')
  if fuzz_target:
    logs.log('Use previously picked fuzz target %s for fuzzing.' % fuzz_target)
    return fuzz_target

  if not environment.is_engine_fuzzer_job():
    return None

  fuzz_targets = list(fuzz_targets)
  if not fuzz_targets:
    logs.log_error('No fuzz targets found. Unable to pick random one.')
    return None

  environment.set_value('FUZZ_TARGET_COUNT', len(fuzz_targets))

  fuzz_target = fuzzer_selection.select_fuzz_target(fuzz_targets,
                                                    target_weights)
  environment.set_value('FUZZ_TARGET', fuzz_target)
  logs.log('Picked fuzz target %s for fuzzing.' % fuzz_target)

  return fuzz_target",_1471.py,5,'Use previously picked fuzz target %s for fuzzing.' % fuzz_target,f'Use previously picked fuzz target {fuzz_target} for fuzzing.',1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/tests/functional/test_config.py,"def test_random_large_hexlify_config(self):
        """"""
        test long config entries with hexlified data with many split entries

        config entry max length is 2000 -
        entry should be split up into 40 parts
        """"""
        for i in range(1, 10):

            length = 1000 * i + random.randint(0, 1000)

            config_data = binascii.hexlify(create_long_entries(length))

            config_entry = ""longHexConfigEntry%d"" % i
            self.entries.add(config_entry)

            param = {config_entry: config_data}
            response = self.make_system_request(""setConfig"", params=param)

            assert '""status"": true' in response, response

            param = {""key"": config_entry}
            response = self.make_system_request(""getConfig"", params=param)
            jresp = json.loads(response.body)

            entry_name = ""getConfig %s"" % config_entry
            data = jresp.get(""result"", {}).get(""value"", {}).get(entry_name)

            assert (
                config_data.decode(""utf-8"") == data
            ), ""error while comparing data""

        self.delete_config(prefix=""longHexConfigEntry"")

        return",_1473.py,14,'longHexConfigEntry%d' % i,f'longHexConfigEntry{i}',1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/tests/functional/test_config.py,"def test_random_large_hexlify_config(self):
        """"""
        test long config entries with hexlified data with many split entries

        config entry max length is 2000 -
        entry should be split up into 40 parts
        """"""
        for i in range(1, 10):

            length = 1000 * i + random.randint(0, 1000)

            config_data = binascii.hexlify(create_long_entries(length))

            config_entry = ""longHexConfigEntry%d"" % i
            self.entries.add(config_entry)

            param = {config_entry: config_data}
            response = self.make_system_request(""setConfig"", params=param)

            assert '""status"": true' in response, response

            param = {""key"": config_entry}
            response = self.make_system_request(""getConfig"", params=param)
            jresp = json.loads(response.body)

            entry_name = ""getConfig %s"" % config_entry
            data = jresp.get(""result"", {}).get(""value"", {}).get(entry_name)

            assert (
                config_data.decode(""utf-8"") == data
            ), ""error while comparing data""

        self.delete_config(prefix=""longHexConfigEntry"")

        return",_1473.py,26,'getConfig %s' % config_entry,f'getConfig {config_entry}',1.0
https://github.com/ldx/python-iptables/tree/master/iptc/xtables.py,"def _fcheck_target_new(self, target):
        # new API
        cb = xt_fcheck_call()
        cb.ext_name = target.name
        cb.data = ct.cast(target.t[0].data, ct.c_void_p)
        cb.xflags = target.tflags
        cb.udata = target.udata
        rv = _wrap_x6fn(target.x6_fcheck, ct.pointer(cb))
        if rv:
            raise XTablesError(""%s.x6_fcheck has failed"" % (target.name))
        if target.x6_options:
            self._options_fcheck(target.name, target.tflags,
                                 target.x6_options)",_1482.py,10,'%s.x6_fcheck has failed' % target.name,f'{target.name}.x6_fcheck has failed',1.0
https://github.com/openstack/nova/tree/master/nova/tests/functional/test_servers_resource_request.py,"def test_evacuate_with_qos_port_pci_update_fail(self):
        # Update the name of the network device RP of PF2 on host2 to something
        # unexpected. This will cause
        # update_pci_request_spec_with_allocated_interface_name() to raise
        # when the instance is evacuated to the host2.
        rsp = self.placement.put(
            '/resource_providers/%s'
            % self.sriov_dev_rp_per_host[self.compute2_rp_uuid][self.PF2],
            {""name"": ""invalid-device-rp-name""})
        self.assertEqual(200, rsp.status)

        non_qos_port = self.neutron.port_1
        qos_port = self.neutron.port_with_resource_request
        qos_sriov_port = self.neutron.port_with_sriov_resource_request

        server = self._create_server_with_ports_and_check_allocation(
            non_qos_port, qos_port, qos_sriov_port)

        # force source compute down
        self.compute1.stop()
        self.admin_api.put_service(
            self.compute1_service_id, {'forced_down': 'true'})

        # The compute manager on host2 will raise from
        # update_pci_request_spec_with_allocated_interface_name
        server = self._evacuate_server(
            server, expected_host='host1', expected_state='ERROR',
            expected_task_state=None, expected_migration_status='failed')

        self.assertIn(
            'does not have a properly formatted name',
            server['fault']['message'])

        self._wait_for_action_fail_completion(
            server, instance_actions.EVACUATE, 'compute_rebuild_instance')

        self.notifier.wait_for_versioned_notifications(
            'instance.rebuild.error')
        self.notifier.wait_for_versioned_notifications(
            'compute.exception')

        # and the instance allocates from the source host
        self._check_allocation(
            server, self.compute1_rp_uuid, non_qos_port, qos_port,
            qos_sriov_port, self.flavor_with_group_policy)",_1502.py,7,'/resource_providers/%s' % self.sriov_dev_rp_per_host[self.compute2_rp_uuid][self.PF2],f'/resource_providers/{self.sriov_dev_rp_per_host[self.compute2_rp_uuid][self.PF2]}',1.0
https://github.com/coleifer/peewee/tree/master/tests/regressions.py,"def test_reselect_model_regression(self):
        u1, u2, u3 = [User.create(username='u%s' % i) for i in '123']

        query = User.select(User.username).order_by(User.username.desc())
        self.assertEqual(list(query.tuples()), [('u3',), ('u2',), ('u1',)])

        query = query.select(User)
        self.assertEqual(list(query.tuples()), [
            (u3.id, 'u3',),
            (u2.id, 'u2',),
            (u1.id, 'u1',)])",_1514.py,2,'u%s' % i,f'u{i}',1.0
https://github.com/athena-team/athena/tree/master/examples/tts/data_baker/local/prepare_data.py,"def process_wav(dataset_dir):
    """"""Downsampling wav and return wav dict
    """"""
    audio_dir = os.path.join(dataset_dir, ""BZNSYP/"")
    os.makedirs(os.path.join(audio_dir, ""Wave_24""), exist_ok=True)
    wav_files = os.listdir(os.path.join(audio_dir, ""Wave""))
    wav_dict = {}

    for wav in wav_files:
        utt_id = os.path.splitext(wav)[0]
        wav48k = os.path.join(audio_dir, 'Wave', wav)
        wav24k = os.path.join(audio_dir, 'Wave_24', wav)
        subprocess.getoutput(
            'cat %s | /usr/bin/sox -t wav - -c 1 -b 16 -t wav - rate 24000  >  %s' % (wav48k, wav24k))
        wav_length = get_wave_file_length(wav24k)
        wav_dict.update({utt_id: [wav24k, wav_length]})
    return wav_dict",_1538.py,14,"'cat %s | /usr/bin/sox -t wav - -c 1 -b 16 -t wav - rate 24000  >  %s' % (wav48k, wav24k)",f'cat {wav48k} | /usr/bin/sox -t wav - -c 1 -b 16 -t wav - rate 24000  >  {wav48k}',1.0
https://github.com/cuemacro/findatapy/tree/master/findatapy/timeseries/calculations.py,"def _safe_update(self, d, other):
        """"""
        Combine dictionaries with non-overlapping keys
        """"""
        for k, v in compat.iteritems(other):
            if k in d:
                raise Exception('Duplicate regressor: %s' % k)

            d[k] = v",_1586.py,7,'Duplicate regressor: %s' % k,f'Duplicate regressor: {k}',1.0
https://github.com/RDFLib/rdflib/tree/master/test/test_initbindings.py,"def testOrderByLimitOffset():
    a = set(
        g.query(
            ""SELECT ?target WHERE { } ORDER BY ?target LIMIT 1 OFFSET 1"",
            initBindings={""target"": Literal(""example"")},
        )
    )
    b = set(
        g.query(
            ""SELECT ?target WHERE { } ORDER BY ?target LIMIT 1 OFFSET 1 VALUES (?target) {('example')}""
        )
    )
    assert a == b, ""orderbyLimitOffset: %r != %r"" % (a, b)",_1601.py,13,"'orderbyLimitOffset: %r != %r' % (a, b)",f'orderbyLimitOffset: {a} != {a}',1.0
https://github.com/ansible/ansible-modules-core/tree/master/system/user.py,"def create_user(self):
        cmd = [
            self.module.get_bin_path('pw', True),
            'useradd',
            '-n',
            self.name,
        ]

        if self.uid is not None:
            cmd.append('-u')
            cmd.append(self.uid)

            if self.non_unique:
                cmd.append('-o')

        if self.comment is not None:
            cmd.append('-c')
            cmd.append(self.comment)

        if self.home is not None:
            cmd.append('-d')
            cmd.append(self.home)

        if self.group is not None:
            if not self.group_exists(self.group):
                self.module.fail_json(msg=""Group %s does not exist"" % self.group)
            cmd.append('-g')
            cmd.append(self.group)

        if self.groups is not None:
            groups = self.get_groups_set()
            cmd.append('-G')
            cmd.append(','.join(groups))

        if self.createhome:
            cmd.append('-m')

            if self.skeleton is not None:
                cmd.append('-k')
                cmd.append(self.skeleton)

        if self.shell is not None:
            cmd.append('-s')
            cmd.append(self.shell)

        if self.login_class is not None:
            cmd.append('-L')
            cmd.append(self.login_class)

        if self.expires:
            days =( time.mktime(self.expires) - time.time() ) / 86400
            cmd.append('-e')
            cmd.append(str(int(days)))

        # system cannot be handled currently - should we error if its requested?
        # create the user
        (rc, out, err) = self.execute_command(cmd)
        if rc is not None and rc != 0:
            self.module.fail_json(name=self.name, msg=err, rc=rc)

        # we have to set the password in a second command
        if self.password is not None:
            cmd = [
                self.module.get_bin_path('chpass', True),
                '-p',
                self.password,
                self.name
            ]
            return self.execute_command(cmd)

        return (rc, out, err)",_1614.py,26,'Group %s does not exist' % self.group,f'Group {self.group} does not exist',1.0
https://github.com/sobhe/hazm/tree/master/hazm/WikiExtractor.py,"def makeExternalLink(url, anchor):
    """"""Function applied to wikiLinks""""""
    if options.keepLinks:
        return '<a href=""%s"">%s</a>' % (quote(url.encode('utf-8')), anchor)
    else:
        return anchor",_162.py,4,"'<a href=""%s"">%s</a>' % (quote(url.encode('utf-8')), anchor)","f'''<a href=""{quote(url.encode('utf-8'))}"">{quote(url.encode('utf-8'))}</a>'''",1.0
https://github.com/wagtail/wagtail/tree/master/wagtail/core/tests/test_permission_policies.py,"def assertUserInstancePermissionMatrix(self, instance, test_cases):
        """"""
        Given a list of (user, can_change, can_delete, can_frobnicate) tuples
        (where 'frobnicate' is an unrecognised action not defined on the model),
        confirm that all tuples correctly represent permissions for that user on
        the given instance, as returned by user_has_permission_for_instance
        """"""
        actions = ['change', 'delete', 'frobnicate']
        for test_case in test_cases:
            user = test_case[0]
            expected_results = zip(actions, test_case[1:])

            for (action, expected_result) in expected_results:
                if expected_result:
                    self.assertTrue(
                        self.policy.user_has_permission_for_instance(user, action, instance),
                        ""User %s should be able to %s instance %s, but can't"" % (
                            user, action, instance
                        )
                    )
                else:
                    self.assertFalse(
                        self.policy.user_has_permission_for_instance(user, action, instance),
                        ""User %s should not be able to %s instance %s, but can"" % (
                            user, action, instance
                        )
                    )",_1627.py,17,"""User %s should be able to %s instance %s, but can't"" % (user, action, instance)","f""User {user} should be able to {user} instance {user}, but can't""",1.0
https://github.com/wagtail/wagtail/tree/master/wagtail/core/tests/test_permission_policies.py,"def assertUserInstancePermissionMatrix(self, instance, test_cases):
        """"""
        Given a list of (user, can_change, can_delete, can_frobnicate) tuples
        (where 'frobnicate' is an unrecognised action not defined on the model),
        confirm that all tuples correctly represent permissions for that user on
        the given instance, as returned by user_has_permission_for_instance
        """"""
        actions = ['change', 'delete', 'frobnicate']
        for test_case in test_cases:
            user = test_case[0]
            expected_results = zip(actions, test_case[1:])

            for (action, expected_result) in expected_results:
                if expected_result:
                    self.assertTrue(
                        self.policy.user_has_permission_for_instance(user, action, instance),
                        ""User %s should be able to %s instance %s, but can't"" % (
                            user, action, instance
                        )
                    )
                else:
                    self.assertFalse(
                        self.policy.user_has_permission_for_instance(user, action, instance),
                        ""User %s should not be able to %s instance %s, but can"" % (
                            user, action, instance
                        )
                    )",_1627.py,24,"'User %s should not be able to %s instance %s, but can' % (user, action, instance)","f'User {user} should not be able to {user} instance {user}, but can'",1.0
https://github.com/Scalsol/mega.pytorch/tree/master/mega_core/data/datasets/evaluation/cityscapes/eval_instances.py,"def __repr__(self):
        """"""
        A weird looking pretty print for Evaluation Arguments
        """"""
        longest_key = max([len(str(k)) for k in self.__dict__.keys()])
        longest_val = max([len(str(v)) for v in self.__dict__.values()])
        s = ""\n"" + ""#"" * max(79, (longest_key + longest_val + 3)) + ""\n""
        for k, v in self.__dict__.items():
            s += ""%{}s : %s\n"".format(longest_key) % (k, v)
        s += ""#"" * max(79, (longest_key + longest_val + 3)) + ""\n""
        return s",_1659.py,9,"%{}s : %s\n'.format(longest_key) % (k, v)",f'{longest_key} : {v}\n',1
https://github.com/kozec/syncthing-gtk/tree/master/syncthing_gtk/windows.py,"def _store(self, r, name, tp, value):
			"""""" Stores value in registry, handling special types """"""
			if tp in (unicode, str):
				_winreg.SetValueEx(r, name, 0, _winreg.REG_SZ, str(value))
			elif tp in (int, bool):
				value = int(value)
				if value > 0xFFFF:
					raise ValueError(""Overflow"")
				if value < 0:
					# This basicaly prevents storing anything >0xFFFF to registry.
					# Luckily, that shouldn't be needed, largest thing stored as int is 20
					value = 0xFFFF + (-value)
				_winreg.SetValueEx(r, name, 0, _winreg.REG_DWORD, int(value))
			elif tp in (list, tuple):
				if not value is None:	# None is default value for window_position
					_winreg.SetValueEx(r, ""%s_size"" % (name,), 0, _winreg.REG_DWORD, len(value))
					for i in xrange(0, len(value)):
						self._store(r, ""%s_%s"" % (name, i), type(value[i]), value[i])
			else:
				_winreg.SetValueEx(r, name, 0, _winreg.REG_SZ, serializer(value))",_1710.py,16,"'%s_size' % (name,)",f'{name}_size',1.0
https://github.com/kozec/syncthing-gtk/tree/master/syncthing_gtk/windows.py,"def _store(self, r, name, tp, value):
			"""""" Stores value in registry, handling special types """"""
			if tp in (unicode, str):
				_winreg.SetValueEx(r, name, 0, _winreg.REG_SZ, str(value))
			elif tp in (int, bool):
				value = int(value)
				if value > 0xFFFF:
					raise ValueError(""Overflow"")
				if value < 0:
					# This basicaly prevents storing anything >0xFFFF to registry.
					# Luckily, that shouldn't be needed, largest thing stored as int is 20
					value = 0xFFFF + (-value)
				_winreg.SetValueEx(r, name, 0, _winreg.REG_DWORD, int(value))
			elif tp in (list, tuple):
				if not value is None:	# None is default value for window_position
					_winreg.SetValueEx(r, ""%s_size"" % (name,), 0, _winreg.REG_DWORD, len(value))
					for i in xrange(0, len(value)):
						self._store(r, ""%s_%s"" % (name, i), type(value[i]), value[i])
			else:
				_winreg.SetValueEx(r, name, 0, _winreg.REG_SZ, serializer(value))",_1710.py,18,"'%s_%s' % (name, i)",f'{name}_{name}',1.0
https://github.com/atpaino/deep-text-corrector/tree/master//seq2seq.py,"def attention(query):
            """"""Put attention masks on hidden using hidden_features and query.""""""
            ds = []  # Results of attention reads will be stored here.
            if nest.is_sequence(query):  # If the query is a tuple, flatten it.
                query_list = nest.flatten(query)
                for q in query_list:  # Check that ndims == 2 if specified.
                    ndims = q.get_shape().ndims
                    if ndims:
                        assert ndims == 2
                query = array_ops.concat(1, query_list)
            for a in xrange(num_heads):
                with variable_scope.variable_scope(""Attention_%d"" % a):
                    y = linear(query, attention_vec_size, True)
                    y = array_ops.reshape(y, [-1, 1, 1, attention_vec_size])
                    # Attention mask is a softmax of v^T * tanh(...).
                    s = math_ops.reduce_sum(
                        v[a] * math_ops.tanh(hidden_features[a] + y), [2, 3])
                    a = nn_ops.softmax(s)
                    # Now calculate the attention-weighted vector d.
                    d = math_ops.reduce_sum(
                        array_ops.reshape(a, [-1, attn_length, 1, 1]) * hidden,
                        [1, 2])
                    ds.append(array_ops.reshape(d, [-1, attn_size]))
            return ds",_1718.py,12,'Attention_%d' % a,f'Attention_{a}',1.0
https://github.com/apache/tvm/tree/master/tests/python/contrib/test_sort.py,,_1788.py,8,'Skip because %s is not enabled' % target,f'Skip because {target} is not enabled',1.0
https://github.com/openstack/keystone/tree/master/keystone/tests/unit/test_v3_oauth1.py,,_1809.py,3,"'/users/%(user_id)s/OS-OAUTH1/access_tokens/%(key)s' % {'user_id': self.user_id, 'key': uuid.uuid4().hex}",f'/users/{self.user_id}/OS-OAUTH1/access_tokens/{uuid.uuid4().hex}',1
https://github.com/tanghaibao/jcvi/tree/master/jcvi/formats/agp.py,"def validate(self):
        assert (
            self.orientation in Valid_orientation
        ), ""orientation must be one of {0}"".format(""|"".join(Valid_orientation))
        assert (
            self.component_type in Valid_component_type
        ), ""component_type must be one of {0}"".format(""|"".join(Valid_component_type))
        assert (
            self.object_beg <= self.object_end
        ), ""object_beg needs to be <= object_end""

        if not self.is_gap:
            assert (
                self.component_beg <= self.component_end
            ), ""component_begin must be <= component_end""
            assert (
                self.object_span == self.component_span
            ), ""object_span (%d) must be same as component_span (%d)"" % (
                self.object_span,
                self.component_span,
            )
        else:
            assert self.gap_length >= 1, ""gap_length must be >= 1""
            assert (
                self.object_span == self.gap_length
            ), ""object span (%d) must be same as gap_length (%d)"" % (
                self.object_span,
                self.gap_length,
            )
            assert (
                self.gap_type in Valid_gap_type
            ), ""gap_type must be one of {}, you have {}"".format(
                ""|"".join(Valid_gap_type), self.gap_type
            )

            assert all(
                x in Valid_evidence for x in self.linkage_evidence
            ), ""linkage_evidence must be one of {0}, you have {1}"".format(
                ""|"".join(Valid_evidence), self.linkage_evidence
            )

            if self.linkage == ""no"":
                assert not self.linkage_evidence or self.linkage_evidence[0] in (
                    """",
                    ""na"",
                ), ""linkage no is incompatible with evidence {0}"".format(
                    self.linkage_evidence
                )",_181.py,18,"'object_span (%d) must be same as component_span (%d)' % (self.object_span, self.component_span)",f'object_span ({self.object_span}) must be same as component_span ({self.object_span})',1.0
https://github.com/tanghaibao/jcvi/tree/master/jcvi/formats/agp.py,"def validate(self):
        assert (
            self.orientation in Valid_orientation
        ), ""orientation must be one of {0}"".format(""|"".join(Valid_orientation))
        assert (
            self.component_type in Valid_component_type
        ), ""component_type must be one of {0}"".format(""|"".join(Valid_component_type))
        assert (
            self.object_beg <= self.object_end
        ), ""object_beg needs to be <= object_end""

        if not self.is_gap:
            assert (
                self.component_beg <= self.component_end
            ), ""component_begin must be <= component_end""
            assert (
                self.object_span == self.component_span
            ), ""object_span (%d) must be same as component_span (%d)"" % (
                self.object_span,
                self.component_span,
            )
        else:
            assert self.gap_length >= 1, ""gap_length must be >= 1""
            assert (
                self.object_span == self.gap_length
            ), ""object span (%d) must be same as gap_length (%d)"" % (
                self.object_span,
                self.gap_length,
            )
            assert (
                self.gap_type in Valid_gap_type
            ), ""gap_type must be one of {}, you have {}"".format(
                ""|"".join(Valid_gap_type), self.gap_type
            )

            assert all(
                x in Valid_evidence for x in self.linkage_evidence
            ), ""linkage_evidence must be one of {0}, you have {1}"".format(
                ""|"".join(Valid_evidence), self.linkage_evidence
            )

            if self.linkage == ""no"":
                assert not self.linkage_evidence or self.linkage_evidence[0] in (
                    """",
                    ""na"",
                ), ""linkage no is incompatible with evidence {0}"".format(
                    self.linkage_evidence
                )",_181.py,26,"'object span (%d) must be same as gap_length (%d)' % (self.object_span, self.gap_length)",f'object span ({self.object_span}) must be same as gap_length ({self.object_span})',1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,36,'Version: %s' % vers['version'],"f""Version: {vers['version']}""",1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,37,' full-revisionid: %s' % vers.get('full-revisionid'),"f"" full-revisionid: {vers.get('full-revisionid')}""",1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,38,' dirty: %s' % vers.get('dirty'),"f"" dirty: {vers.get('dirty')}""",1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,39,' date: %s' % vers.get('date'),"f"" date: {vers.get('date')}""",1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,163,'UPDATING %s' % target_versionfile,f'UPDATING {target_versionfile}',1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,41,' error: %s' % vers['error'],"f"" error: {vers['error']}""",1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,76,'UPDATING %s' % target_versionfile,f'UPDATING {target_versionfile}',1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,95,'UPDATING %s' % target_versionfile,f'UPDATING {target_versionfile}',1.0
https://github.com/yaqwsx/PcbDraw/tree/master//versioneer.py,,_1875.py,124,'UPDATING %s' % target_versionfile,f'UPDATING {target_versionfile}',1.0
https://github.com/Boris-code/feapder/tree/master/feapder/utils/tools.py,"def add_zero(n):
    return ""%02d"" % n",_190.py,2,'%02d' % n,f'{n}',1.0
https://github.com/svinota/pyroute2/tree/master/pyroute2.ndb/pr2modules/ndb/transport.py,,_1912.py,3,"'%s-%s' % (message.get('target', '-'), uuid.uuid4().hex)","f""{message.get('target', '-')}-{message.get('target', '-')}""",1.0
https://github.com/EnterpriseDB/barman/tree/master/barman/lockfile.py,,_1955.py,3,'.%s-archive-wal.lock' % server_name,f'.{server_name}-archive-wal.lock',1.0
https://github.com/matrix-org/synapse/tree/master/tests/module_api/test_api.py,,_1979.py,16,'/_matrix/client/r0/profile/%s/displayname' % lesley,f'/_matrix/client/r0/profile/{lesley}/displayname',1.0
https://github.com/matrix-org/synapse/tree/master/tests/module_api/test_api.py,,_1979.py,25,'/_matrix/client/r0/profile/%s/avatar_url' % lesley,f'/_matrix/client/r0/profile/{lesley}/avatar_url',1.0
https://github.com/moloch--/RootTheBox/tree/master/libs/ChatManager.py,"def create_user(self, user, password):
        # Create the user's account on RocketChat
        if not self.rocket:
            return
        email = user.email
        if email is None:
            email = ""%s@rocketchat.com"" % user.uuid
        account = self.rocket.users_create(
            email, user.name, password, user.handle.replace("" "", ""_"")
        ).json()
        self.create_team(user.team, account)",_1980.py,7,'%s@rocketchat.com' % user.uuid,f'{user.uuid}@rocketchat.com',1.0
https://github.com/Python-World/Python_and_the_Web/tree/master/Scripts/Miscellaneous/Streamlit_webapp/Compound_interest.py,,_2005.py,7,'%.3f' % comp,f'{comp}',1.0
https://github.com/jaraco/keyring/tree/master/tests/backends/test_kwallet.py,"def check_set_get(self, service, username, password):
        keyring = self.keyring

        # for the non-existent password
        assert keyring.get_password(service, username) is None

        # common usage
        self.set_password(service, username, password, True)
        # re-init keyring to force migration
        self.keyring = keyring = self.init_keyring()
        ret_password = keyring.get_password(service, username)
        assert ret_password == password, (
            ""Incorrect password for username: '%s' ""
            ""on service: '%s'. '%s' != '%s'""
            % (service, username, ret_password, password),
        )

        # for the empty password
        self.set_password(service, username, """", True)
        # re-init keyring to force migration
        self.keyring = keyring = self.init_keyring()
        ret_password = keyring.get_password(service, username)
        assert ret_password == """", (
            ""Incorrect password for username: '%s' ""
            ""on service: '%s'. '%s' != '%s'"" % (service, username, ret_password, """"),
        )
        ret_password = keyring.get_password('Python', username + '@' + service)
        assert ret_password is None, (
            ""Not 'None' password returned for username: '%s' ""
            ""on service: '%s'. '%s' != '%s'. Passwords from old ""
            ""folder should be deleted during migration.""
            % (service, username, ret_password, None),
        )",_2054.py,29,"""Not 'None' password returned for username: '%s' on service: '%s'. '%s' != '%s'. Passwords from old folder should be deleted during migration."" % (service, username, ret_password, None)","f""Not 'None' password returned for username: '{service}' on service: '{service}'. '{service}' != '{service}'. Passwords from old folder should be deleted during migration.""",1.0
https://github.com/sympy/sympy/tree/master/sympy/physics/quantum/operator.py,"def _print_contents(self, printer, *args):
        if len(self.label) == 1:
            return self._print_label(printer, *args)
        else:
            return '%s(%s)' % (
                self._print_operator_name(printer, *args),
                self._print_label(printer, *args)
            )",_216.py,5,"'%s(%s)' % (self._print_operator_name(printer, *args), self._print_label(printer, *args))","f'{self._print_operator_name(printer, *args)}({self._print_operator_name(printer, *args)})'",1.0
https://github.com/ozgur/python-firebase/tree/master/firebase/firebase.py,"def _build_endpoint_url(self, url, name=None):
        """"""
        Method that constructs a full url with the given url and the
        snapshot name.

        Example:
        full_url = _build_endpoint_url('/users', '1')
        full_url => 'http://firebase.localhost/users/1.json'
        """"""
        if not url.endswith(self.URL_SEPERATOR):
            url = url + self.URL_SEPERATOR
        if name is None:
            name = ''
        return '%s%s%s' % (urlparse.urljoin(self.dsn, url), name,
                           self.NAME_EXTENSION)",_248.py,14,"'%s%s%s' % (urlparse.urljoin(self.dsn, url), name, self.NAME_EXTENSION)","f'{urlparse.urljoin(self.dsn, url)}{urlparse.urljoin(self.dsn, url)}{urlparse.urljoin(self.dsn, url)}'",1.0
https://github.com/opencve/opencve/tree/master/opencve/utils.py,"def _format_line(self, side, flag, linenum, text):
        text = text.replace(""&"", ""&amp;"").replace("">"", ""&gt;"").replace(""<"", ""&lt;"")
        text = text.replace("" "", ""&nbsp;"").rstrip()
        return '<td class=""diff_header"">%s</td><td class=""break"">%s</td>' % (
            linenum,
            text,
        )",_251.py,4,"'<td class=""diff_header"">%s</td><td class=""break"">%s</td>' % (linenum, text)","f'<td class=""diff_header"">{linenum}</td><td class=""break"">{linenum}</td>'",1.0
https://github.com/ansible/ansible/tree/master/lib/ansible/playbook/role/requirement.py,"def role_yaml_parse(role):

        if isinstance(role, string_types):
            name = None
            scm = None
            src = None
            version = None
            if ',' in role:
                if role.count(',') == 1:
                    (src, version) = role.strip().split(',', 1)
                elif role.count(',') == 2:
                    (src, version, name) = role.strip().split(',', 2)
                else:
                    raise AnsibleError(""Invalid role line (%s). Proper format is 'role_name[,version[,name]]'"" % role)
            else:
                src = role

            if name is None:
                name = RoleRequirement.repo_url_to_role_name(src)
            if '+' in src:
                (scm, src) = src.split('+', 1)

            return dict(name=name, src=src, scm=scm, version=version)

        if 'role' in role:
            name = role['role']
            if ',' in name:
                raise AnsibleError(""Invalid old style role requirement: %s"" % name)
            else:
                del role['role']
                role['name'] = name
        else:
            role = role.copy()

            if 'src' in role:
                # New style: { src: 'galaxy.role,version,name', other_vars: ""here"" }
                if 'github.com' in role[""src""] and 'http' in role[""src""] and '+' not in role[""src""] and not role[""src""].endswith('.tar.gz'):
                    role[""src""] = ""git+"" + role[""src""]

                if '+' in role[""src""]:
                    role[""scm""], dummy, role[""src""] = role[""src""].partition('+')

                if 'name' not in role:
                    role[""name""] = RoleRequirement.repo_url_to_role_name(role[""src""])

            if 'version' not in role:
                role['version'] = ''

            if 'scm' not in role:
                role['scm'] = None

        for key in list(role.keys()):
            if key not in VALID_SPEC_KEYS:
                role.pop(key)

        return role",_259.py,14,"""Invalid role line (%s). Proper format is 'role_name[,version[,name]]'"" % role","f""Invalid role line ({role}). Proper format is 'role_name[,version[,name]]'""",1
https://github.com/ansible/ansible/tree/master/lib/ansible/playbook/role/requirement.py,"def role_yaml_parse(role):

        if isinstance(role, string_types):
            name = None
            scm = None
            src = None
            version = None
            if ',' in role:
                if role.count(',') == 1:
                    (src, version) = role.strip().split(',', 1)
                elif role.count(',') == 2:
                    (src, version, name) = role.strip().split(',', 2)
                else:
                    raise AnsibleError(""Invalid role line (%s). Proper format is 'role_name[,version[,name]]'"" % role)
            else:
                src = role

            if name is None:
                name = RoleRequirement.repo_url_to_role_name(src)
            if '+' in src:
                (scm, src) = src.split('+', 1)

            return dict(name=name, src=src, scm=scm, version=version)

        if 'role' in role:
            name = role['role']
            if ',' in name:
                raise AnsibleError(""Invalid old style role requirement: %s"" % name)
            else:
                del role['role']
                role['name'] = name
        else:
            role = role.copy()

            if 'src' in role:
                # New style: { src: 'galaxy.role,version,name', other_vars: ""here"" }
                if 'github.com' in role[""src""] and 'http' in role[""src""] and '+' not in role[""src""] and not role[""src""].endswith('.tar.gz'):
                    role[""src""] = ""git+"" + role[""src""]

                if '+' in role[""src""]:
                    role[""scm""], dummy, role[""src""] = role[""src""].partition('+')

                if 'name' not in role:
                    role[""name""] = RoleRequirement.repo_url_to_role_name(role[""src""])

            if 'version' not in role:
                role['version'] = ''

            if 'scm' not in role:
                role['scm'] = None

        for key in list(role.keys()):
            if key not in VALID_SPEC_KEYS:
                role.pop(key)

        return role",_259.py,28,'Invalid old style role requirement: %s' % name,f'Invalid old style role requirement: {name}',1.0
https://github.com/Blazemeter/taurus/tree/master/bzt/modules/monitoring.py,"def get_data(self):
        now = time.time()

        if now > self._last_check + self.interval:
            self._cached_data = []
            self._last_check = now
            json_list = self._get_response()
            data_line = [now]

            for element in json_list:
                item = {
                    'ts': now,
                    'source': '%s' % self.host_label}

                for datapoint in reversed(element['datapoints']):
                    if datapoint[0] is not None:
                        item[element['target']] = datapoint[0]
                        data_line.append(datapoint[0])
                        break

                self._cached_data.append(item)

            if self.logs_file:
                with open(self.logs_file, ""a"", newline='') as g_logs:
                    logs_writer = csv.writer(g_logs, delimiter=',')
                    logs_writer.writerow(data_line)

        return self._cached_data",_262.py,13,'%s' % self.host_label,f'{self.host_label}',1.0
https://github.com/scrapinghub/portia/tree/master/slyd/slyd/projects.py,"def __str__(self):
        return '%s' % self.user",_267.py,2,'%s' % self.user,f'{self.user}',1.0
https://github.com/mahmoud/glom/tree/master/glom/core.py,"def glom(target, spec, **kwargs):
    """"""Access or construct a value from a given *target* based on the
    specification declared by *spec*.

    Accessing nested data, aka deep-get:

    >>> target = {'a': {'b': 'c'}}
    >>> glom(target, 'a.b')
    'c'

    Here the *spec* was just a string denoting a path,
    ``'a.b.``. As simple as it should be. The next example shows
    how to use nested data to access many fields at once, and make
    a new nested structure.

    Constructing, or restructuring more-complicated nested data:

    >>> target = {'a': {'b': 'c', 'd': 'e'}, 'f': 'g', 'h': [0, 1, 2]}
    >>> spec = {'a': 'a.b', 'd': 'a.d', 'h': ('h', [lambda x: x * 2])}
    >>> output = glom(target, spec)
    >>> pprint(output)
    {'a': 'c', 'd': 'e', 'h': [0, 2, 4]}

    ``glom`` also takes a keyword-argument, *default*. When set,
    if a ``glom`` operation fails with a :exc:`GlomError`, the
    *default* will be returned, very much like
    :meth:`dict.get()`:

    >>> glom(target, 'a.xx', default='nada')
    'nada'

    The *skip_exc* keyword argument controls which errors should
    be ignored.

    >>> glom({}, lambda x: 100.0 / len(x), default=0.0, skip_exc=ZeroDivisionError)
    0.0

    Args:
       target (object): the object on which the glom will operate.
       spec (object): Specification of the output object in the form
         of a dict, list, tuple, string, other glom construct, or
         any composition of these.
       default (object): An optional default to return in the case
         an exception, specified by *skip_exc*, is raised.
       skip_exc (Exception): An optional exception or tuple of
         exceptions to ignore and return *default* (None if
         omitted). If *skip_exc* and *default* are both not set,
         glom raises errors through.
       scope (dict): Additional data that can be accessed
         via S inside the glom-spec. Read more: :ref:`scope`.

    It's a small API with big functionality, and glom's power is
    only surpassed by its intuitiveness. Give it a whirl!

    """"""
    # TODO: check spec up front
    default = kwargs.pop('default', None if 'skip_exc' in kwargs else _MISSING)
    skip_exc = kwargs.pop('skip_exc', () if default is _MISSING else GlomError)
    glom_debug = kwargs.pop('glom_debug', GLOM_DEBUG)
    scope = _DEFAULT_SCOPE.new_child({
        Path: kwargs.pop('path', []),
        Inspect: kwargs.pop('inspector', None),
        MODE: AUTO,
        CHILD_ERRORS: [],
        'globals': ScopeVars({}, {}),
    })
    scope[UP] = scope
    scope[ROOT] = scope
    scope[T] = target
    scope.update(kwargs.pop('scope', {}))
    err = None
    if kwargs:
        raise TypeError('unexpected keyword args: %r' % sorted(kwargs.keys()))
    try:
        try:
            ret = _glom(target, spec, scope)
        except skip_exc:
            if default is _MISSING:
                raise
            ret = default
    except Exception as e:
        if glom_debug:
            raise
        if isinstance(e, GlomError):
            # need to change id or else py3 seems to not let us truncate the
            # stack trace with the explicit ""raise err"" below
            err = copy.copy(e)
            err._set_wrapped(e)
        else:
            err = GlomError.wrap(e)
        if isinstance(err, GlomError):
            err._finalize(scope[LAST_CHILD_SCOPE])
        else:  # wrapping failed, fall back to default behavior
            raise

    if err:
        raise err
    return ret",_28.py,73,'unexpected keyword args: %r' % sorted(kwargs.keys()),f'unexpected keyword args: {sorted(kwargs.keys())}',1.0
https://github.com/Exa-Networks/exabgp/tree/master/src/exabgp/reactor/protocol.py,"def read_open(self, ip):
        for received_open in self.read_message():
            if received_open.TYPE == NOP.TYPE:
                yield received_open
            else:
                break

        if received_open.TYPE != Open.TYPE:
            raise Notify(5, 1, 'The first packet received is not an open message (%s)' % received_open)

        log.debug('<< %s' % received_open, self.connection.session())
        yield received_open",_284.py,11,'<< %s' % received_open,f'<< {received_open}',1.0
https://github.com/Exa-Networks/exabgp/tree/master/src/exabgp/reactor/protocol.py,"def read_open(self, ip):
        for received_open in self.read_message():
            if received_open.TYPE == NOP.TYPE:
                yield received_open
            else:
                break

        if received_open.TYPE != Open.TYPE:
            raise Notify(5, 1, 'The first packet received is not an open message (%s)' % received_open)

        log.debug('<< %s' % received_open, self.connection.session())
        yield received_open",_284.py,9,'The first packet received is not an open message (%s)' % received_open,f'The first packet received is not an open message ({received_open})',1.0
https://github.com/apache/tvm/tree/master/tests/python/unittest/test_target_codegen_llvm.py,"def test_llvm_vadd_pipeline():
    def check_llvm(n, lanes):
        A = te.placeholder((n,), name=""A"", dtype=""float32x%d"" % lanes)
        B = te.compute((n,), lambda i: A[i], name=""B"")
        C = te.compute((n,), lambda i: B[i] + tvm.tir.const(1, A.dtype), name=""C"")
        s = te.create_schedule(C.op)
        xo, xi = s[C].split(C.op.axis[0], nparts=2)
        _, xi = s[C].split(xi, factor=2)
        s[C].parallel(xo)
        s[C].vectorize(xi)
        s[B].compute_at(s[C], xo)
        xo, xi = s[B].split(B.op.axis[0], factor=2)
        s[B].vectorize(xi)
        # build and invoke the kernel.
        f = tvm.build(s, [A, C], ""llvm"")
        dev = tvm.cpu(0)
        # launch the kernel.
        a = tvm.nd.empty((n,), A.dtype).copyfrom(np.random.uniform(size=(n, lanes)))
        c = tvm.nd.empty((n,), C.dtype, dev)
        f(a, c)
        tvm.testing.assert_allclose(c.numpy(), a.numpy() + 1)

    check_llvm(64, 2)
    check_llvm(512, 2)",_298.py,3,'float32x%d' % lanes,f'float32x{lanes}',1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/lib/reply.py,"def create_img(data, width=0, alt=None, img_id=""challenge_qrcode""):
    """"""
    _create_img - create the qr image data

    :param data: input data that will be munched into the qrcode
    :type  data: string
    :param width: image width in pixel
    :type  width: int

    :return: <img/> taged data
    :rtype:  string
    """"""
    width_str = """"
    alt_str = """"

    img_src = create_img_src(data)

    if width != 0:
        width_str = "" width=%d "" % (int(width))

    if alt is not None:
        val = urllib.parse.urlencode({""alt"": alt})
        alt_str = "" alt=%r "" % (val[len(""alt="") :])

    ret_img = '<img id=""%s"" %s  %s  src=""%s""/>' % (
        img_id,
        alt_str,
        width_str,
        img_src,
    )

    return ret_img",_307.py,25,"'<img id=""%s"" %s  %s  src=""%s""/>' % (img_id, alt_str, width_str, img_src)","f'<img id=""{img_id}"" {img_id}  {img_id}  src=""{img_id}""/>'",1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/lib/reply.py,"def create_img(data, width=0, alt=None, img_id=""challenge_qrcode""):
    """"""
    _create_img - create the qr image data

    :param data: input data that will be munched into the qrcode
    :type  data: string
    :param width: image width in pixel
    :type  width: int

    :return: <img/> taged data
    :rtype:  string
    """"""
    width_str = """"
    alt_str = """"

    img_src = create_img_src(data)

    if width != 0:
        width_str = "" width=%d "" % (int(width))

    if alt is not None:
        val = urllib.parse.urlencode({""alt"": alt})
        alt_str = "" alt=%r "" % (val[len(""alt="") :])

    ret_img = '<img id=""%s"" %s  %s  src=""%s""/>' % (
        img_id,
        alt_str,
        width_str,
        img_src,
    )

    return ret_img",_307.py,19,' width=%d ' % int(width),f' width={int(width)} ',1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/lib/reply.py,"def create_img(data, width=0, alt=None, img_id=""challenge_qrcode""):
    """"""
    _create_img - create the qr image data

    :param data: input data that will be munched into the qrcode
    :type  data: string
    :param width: image width in pixel
    :type  width: int

    :return: <img/> taged data
    :rtype:  string
    """"""
    width_str = """"
    alt_str = """"

    img_src = create_img_src(data)

    if width != 0:
        width_str = "" width=%d "" % (int(width))

    if alt is not None:
        val = urllib.parse.urlencode({""alt"": alt})
        alt_str = "" alt=%r "" % (val[len(""alt="") :])

    ret_img = '<img id=""%s"" %s  %s  src=""%s""/>' % (
        img_id,
        alt_str,
        width_str,
        img_src,
    )

    return ret_img",_307.py,23,' alt=%r ' % val[len('alt='):],"f"" alt={val[len('alt='):]} """,1.0
https://github.com/MultiAgentLearning/playground/tree/master/pommerman/characters.py,"def set_agent_id(self, agent_id):
        self.agent_id = agent_id
        if self._game_type == constants.GameType.FFA:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id
            ]
        elif self._game_type == constants.GameType.OneVsOne:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(2)
                if id_ != agent_id
            ]
        else:
            teammate_id = (agent_id + 2) % 4
            self.teammate = getattr(constants.Item, 'Agent%d' % teammate_id)
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id and id_ != teammate_id
            ]
            self.enemies.append(constants.Item.AgentDummy)",_308.py,6,'Agent%d' % id_,f'Agent{id_}',1.0
https://github.com/MultiAgentLearning/playground/tree/master/pommerman/characters.py,"def set_agent_id(self, agent_id):
        self.agent_id = agent_id
        if self._game_type == constants.GameType.FFA:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id
            ]
        elif self._game_type == constants.GameType.OneVsOne:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(2)
                if id_ != agent_id
            ]
        else:
            teammate_id = (agent_id + 2) % 4
            self.teammate = getattr(constants.Item, 'Agent%d' % teammate_id)
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id and id_ != teammate_id
            ]
            self.enemies.append(constants.Item.AgentDummy)",_308.py,19,'Agent%d' % teammate_id,f'Agent{teammate_id}',1.0
https://github.com/MultiAgentLearning/playground/tree/master/pommerman/characters.py,"def set_agent_id(self, agent_id):
        self.agent_id = agent_id
        if self._game_type == constants.GameType.FFA:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id
            ]
        elif self._game_type == constants.GameType.OneVsOne:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(2)
                if id_ != agent_id
            ]
        else:
            teammate_id = (agent_id + 2) % 4
            self.teammate = getattr(constants.Item, 'Agent%d' % teammate_id)
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id and id_ != teammate_id
            ]
            self.enemies.append(constants.Item.AgentDummy)",_308.py,13,'Agent%d' % id_,f'Agent{id_}',1.0
https://github.com/MultiAgentLearning/playground/tree/master/pommerman/characters.py,"def set_agent_id(self, agent_id):
        self.agent_id = agent_id
        if self._game_type == constants.GameType.FFA:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id
            ]
        elif self._game_type == constants.GameType.OneVsOne:
            self.teammate = constants.Item.AgentDummy
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(2)
                if id_ != agent_id
            ]
        else:
            teammate_id = (agent_id + 2) % 4
            self.teammate = getattr(constants.Item, 'Agent%d' % teammate_id)
            self.enemies = [
                getattr(constants.Item, 'Agent%d' % id_)
                for id_ in range(4)
                if id_ != agent_id and id_ != teammate_id
            ]
            self.enemies.append(constants.Item.AgentDummy)",_308.py,21,'Agent%d' % id_,f'Agent{id_}',1.0
https://github.com/GetTogetherComm/GetTogether/tree/master/events/management/commands/load_spr.py,"def handle(self, *args, **options):
        if ""file"" in options:
            # Preload country cache
            for country in Country.objects.all():
                COUNTRY_CACHE[country.code] = country
            with open(options[""file""], ""r"") as spr_file:
                for spr_line in spr_file.readlines():
                    if spr_line.startswith(""#""):
                        continue
                    spr = spr_line.split(""\t"")
                    if len(spr) == 4:
                        COUNTRY_CODE, SPR_CODE = spr[COMBINED_CODE].split(""."")
                        country = COUNTRY_CACHE.get(COUNTRY_CODE)
                        if country is not None:
                            # print(""%s - %s, %s"" % (SPR_CODE, spr[NAME], country.name))
                            SPR.objects.get_or_create(
                                name=spr[NAME], code=SPR_CODE, country=country
                            )
                    else:
                        print(""Short line (%s): %s"" % (len(spr), spr_line))
        else:
            print(""No File in options!"")",_337.py,20,"'Short line (%s): %s' % (len(spr), spr_line)",f'Short line ({len(spr)}): {len(spr)}',1.0
https://github.com/CSAILVision/gandissect/tree/master/netdissect/aceoptimize.py,"def summarize_scores(args, corpus, cachedir, layer, classname, variant, scores):
    target_filename = os.path.join(cachedir, 'summary.json')

    ranking_name = '%s-%s' % (classname, variant)
    # Now convert ace scores to rankings
    new_rankings = [dict(
        name=ranking_name,
        score=(-scores).flatten().tolist(),
        metric=variant)]
    result = dict(layers=[dict(layer=layer, rankings=new_rankings)])

    # Replace the old dissect.json in-place
    with open(target_filename, 'w') as f:
        json.dump(result, f, indent=1)",_354.py,4,"'%s-%s' % (classname, variant)",f'{classname}-{classname}',1.0
https://github.com/quodlibet/quodlibet/tree/master/quodlibet/ext/songsmenu/cover_download.py,"def _sent(self, msg, result, data):
        headers = self.message.get_property('response-headers')
        self.size = int(headers.get('content-length'))
        self._content_type = headers.get('content-type')
        self._original = result
        try:
            loader = GdkPixbuf.PixbufLoader()
        except GLib.GError as e:
            print_w(""Couldn't create GdkPixbuf (%s)"" % e)
        else:
            loader.write(result)
            loader.close()
            self._pixbuf = loader.get_pixbuf()
            self.emit(""info-known"", self._content_type, self.size,
                      self._pixbuf.props)
            self.resize()
            self.queue_draw()",_39.py,9,"""Couldn't create GdkPixbuf (%s)"" % e","f""Couldn't create GdkPixbuf ({e})""",1.0
https://github.com/stevearc/pypicloud/tree/master/pypicloud/access/base.py,"def _hmac(self, username: str, timestamp: float) -> Tuple[str, str]:
        """"""HMAC a username/expiration combo""""""
        if self.signing_key is None:
            raise RuntimeError(""auth.signing_key is not set!"")
        msg = ""%s:%d"" % (username, timestamp)
        return (
            msg,
            hmac.new(
                self.signing_key.encode(""utf8""), msg.encode(""utf8""), hashlib.sha256
            ).hexdigest(),
        )",_459.py,5,"'%s:%d' % (username, timestamp)",f'{username}:{timestamp}',1.0
https://github.com/Mailu/Mailu/tree/master/core/admin/mailu/ui/views/alternatives.py,"def alternative_delete(alternative):
    alternative = models.Alternative.query.get(alternative) or flask.abort(404)
    domain = alternative.domain
    models.db.session.delete(alternative)
    models.db.session.commit()
    flask.flash('Alternative %s deleted' % alternative)
    return flask.redirect(
        flask.url_for('.alternative_list', domain_name=domain.name))",_464.py,6,'Alternative %s deleted' % alternative,f'Alternative {alternative} deleted',1.0
https://github.com/QUANTAXIS/QUANTAXIS/tree/master/QUANTAXIS/QASU/save_tushare.py,"def saving_work(i):
        QA_util_log_info('Now Saving ==== %s' % (i))
        try:
            df = QA_fetch_get_stock_day(i, start='1990-01-01', if_fq='bfq')

            __coll.insert_many(json.loads(df.to_json(orient='records')))
        except Exception as e:
            print(e)
            QA_util_log_info('error in saving ==== %s' % str(i))",_466.py,2,'Now Saving ==== %s' % i,f'Now Saving ==== {i}',1.0
https://github.com/QUANTAXIS/QUANTAXIS/tree/master/QUANTAXIS/QASU/save_tushare.py,"def saving_work(i):
        QA_util_log_info('Now Saving ==== %s' % (i))
        try:
            df = QA_fetch_get_stock_day(i, start='1990-01-01', if_fq='bfq')

            __coll.insert_many(json.loads(df.to_json(orient='records')))
        except Exception as e:
            print(e)
            QA_util_log_info('error in saving ==== %s' % str(i))",_466.py,9,'error in saving ==== %s' % str(i),f'error in saving ==== {str(i)}',1.0
https://github.com/sibears/IDAGolangHelper/tree/master/GO_Utils/Types.py,"def processMethods(self, offst):
        sid = ida_struct.get_struc_id(""method__"")
        name = self.getDword(sid, offst, ""name"")
        name += self.robase
        name = self.get_str(name + 3, idc.get_wide_byte(name + 2))
        type_meth = self.getDword(sid, offst, ""mtyp"")
        type_meth_addr1 = self.robase + type_meth
        func_body1 = self.getDword(sid, offst, ""ifn"")
        func_addr1 = self.text_addr + func_body1
        func_body2 = self.getDword(sid, offst, ""tfn"")
        func_addr2 = self.text_addr + func_body1
        return ""%s %x %x %x"" % (name, type_meth_addr1, func_addr1, func_addr2)",_506.py,12,"'%s %x %x %x' % (name, type_meth_addr1, func_addr1, func_addr2)",f'{name} {type_meth_addr1} {type_meth_addr1} {type_meth_addr1}',1.0
https://github.com/amfoss/cms/tree/master/cms/grading/tasktypes/TwoSteps.py,"def get_compilation_commands(self, submission_format):
        """"""See TaskType.get_compilation_commands.""""""
        res = dict()
        for language in LANGUAGES:
            source_ext = language.source_extension
            header_ext = language.header_extension
            source_filenames = []
            # Manager
            manager_source_filename = ""manager%s"" % source_ext
            source_filenames.append(manager_source_filename)
            # Manager's header.
            if header_ext is not None:
                manager_header_filename = ""manager%s"" % header_ext
                source_filenames.append(manager_header_filename)

            for filename in submission_format:
                source_filename = filename.replace("".%l"", source_ext)
                source_filenames.append(source_filename)
                # Headers
                if header_ext is not None:
                    header_filename = filename.replace("".%l"", header_ext)
                    source_filenames.append(header_filename)

            # Get compilation command and compile.
            executable_filename = ""manager"" + language.executable_extension
            commands = language.get_compilation_commands(
                source_filenames, executable_filename)
            res[language.name] = commands
        return res",_543.py,9,'manager%s' % source_ext,f'manager{source_ext}',1.0
https://github.com/amfoss/cms/tree/master/cms/grading/tasktypes/TwoSteps.py,"def get_compilation_commands(self, submission_format):
        """"""See TaskType.get_compilation_commands.""""""
        res = dict()
        for language in LANGUAGES:
            source_ext = language.source_extension
            header_ext = language.header_extension
            source_filenames = []
            # Manager
            manager_source_filename = ""manager%s"" % source_ext
            source_filenames.append(manager_source_filename)
            # Manager's header.
            if header_ext is not None:
                manager_header_filename = ""manager%s"" % header_ext
                source_filenames.append(manager_header_filename)

            for filename in submission_format:
                source_filename = filename.replace("".%l"", source_ext)
                source_filenames.append(source_filename)
                # Headers
                if header_ext is not None:
                    header_filename = filename.replace("".%l"", header_ext)
                    source_filenames.append(header_filename)

            # Get compilation command and compile.
            executable_filename = ""manager"" + language.executable_extension
            commands = language.get_compilation_commands(
                source_filenames, executable_filename)
            res[language.name] = commands
        return res",_543.py,13,'manager%s' % header_ext,f'manager{header_ext}',1.0
https://github.com/gavin66/proxy_list/tree/master/persistence/redis_impl.py,"def list(self, count=1, query=None, columns=None):
        query_list = list()
        if query:
            for k, v in query.items():
                if k in self._index_keys:
                    query_list.append('index_%s_%s' % (k, v))
            keys = list(self._client.sinter(query_list))
            keys.sort(key=lambda x: float(self._client.zscore('index_speed', x)))
            if isinstance(count, int):
                keys = keys[:count]
        else:
            start = 0
            if isinstance(count, str):
                count = None
                start = None
            keys = list(self._client.zrangebyscore('index_speed', '-inf', '+inf', start=start, num=count))
        proxies = []
        for key in keys:
            proxy = self._client.hgetall(key)
            if isinstance(columns, tuple) and len(columns):
                x = {}
                for k in columns:
                    if k.encode('utf-8') in proxy.keys():
                        x[k] = proxy[k.encode('utf-8')].decode('utf-8')
                proxies.append(x)
            elif isinstance(columns, str) and columns == 'all':
                # ip, port, country, address, anonymity, protocol, speed
                proxies.append({x.decode('utf-8'): y.decode('utf-8') for x, y in proxy.items()})
            else:
                proxies.append(
                    (proxy[b'ip'].decode('utf-8'), proxy[b'port'].decode('utf-8'))
                )
        return proxies",_565.py,6,"'index_%s_%s' % (k, v)",f'index_{k}_{k}',1.0
https://github.com/biocore/scikit-bio/tree/master/skbio/alignment/_pairwise.py,"def local_pairwise_align_ssw(sequence1, sequence2, **kwargs):
    """"""Align query and target sequences with Striped Smith-Waterman.

    Parameters
    ----------
    sequence1 : DNA, RNA, or Protein
        The first unaligned sequence
    sequence2 : DNA, RNA, or Protein
        The second unaligned sequence

    Returns
    -------
    tuple
        ``TabularMSA`` object containing the aligned sequences, alignment score
        (float), and start/end positions of each input sequence (iterable
        of two-item tuples). Note that start/end positions are indexes into the
        unaligned sequences.

    Notes
    -----
    This is a wrapper for the SSW package [1]_.

    For a complete list of optional keyword-arguments that can be provided,
    see ``skbio.alignment.StripedSmithWaterman``.

    The following kwargs will not have any effect: `suppress_sequences`,
    `zero_index`, and `protein`

    If an alignment does not meet a provided filter, `None` will be returned.

    References
    ----------
    .. [1] Zhao, Mengyao, Wan-Ping Lee, Erik P. Garrison, & Gabor T.
       Marth. ""SSW Library: An SIMD Smith-Waterman C/C++ Library for
       Applications"". PLOS ONE (2013). Web. 11 July 2014.
       http://www.plosone.org/article/info:doi/10.1371/journal.pone.0082138

    See Also
    --------
    skbio.alignment.StripedSmithWaterman

    """"""
    for seq in sequence1, sequence2:
        if not isinstance(seq, (DNA, RNA, Protein)):
            raise TypeError(
                ""`sequence1` and `sequence2` must be DNA, RNA, or Protein, ""
                ""not type %r"" % type(seq).__name__)

    if type(sequence1) is not type(sequence2):
        raise TypeError(
            ""`sequence1` and `sequence2` must be the same type: %r != %r""
            % (type(sequence1).__name__, type(sequence2).__name__))

    # We need the sequences for `TabularMSA` to make sense, so don't let the
    # user suppress them.
    kwargs['suppress_sequences'] = False
    kwargs['zero_index'] = True

    kwargs['protein'] = False
    if isinstance(sequence1, Protein):
        kwargs['protein'] = True

    query = StripedSmithWaterman(str(sequence1), **kwargs)
    alignment = query(str(sequence2))

    # If there is no cigar, then it has failed a filter. Return None.
    if not alignment.cigar:
        return None

    start_end = None
    if alignment.query_begin != -1:
        start_end = [
            (alignment.query_begin, alignment.query_end),
            (alignment.target_begin, alignment.target_end_optimal)
        ]

    metadata1 = metadata2 = None
    if sequence1.has_metadata():
        metadata1 = sequence1.metadata
    if sequence2.has_metadata():
        metadata2 = sequence2.metadata

    constructor = type(sequence1)
    msa = TabularMSA([
        constructor(alignment.aligned_query_sequence, metadata=metadata1,
                    validate=False),
        constructor(alignment.aligned_target_sequence, metadata=metadata2,
                    validate=False)
    ])

    return msa, alignment.optimal_alignment_score, start_end",_57.py,51,"'`sequence1` and `sequence2` must be the same type: %r != %r' % (type(sequence1).__name__, type(sequence2).__name__)",f'`sequence1` and `sequence2` must be the same type: {type(sequence1).__name__} != {type(sequence1).__name__}',1.0
https://github.com/biocore/scikit-bio/tree/master/skbio/alignment/_pairwise.py,"def local_pairwise_align_ssw(sequence1, sequence2, **kwargs):
    """"""Align query and target sequences with Striped Smith-Waterman.

    Parameters
    ----------
    sequence1 : DNA, RNA, or Protein
        The first unaligned sequence
    sequence2 : DNA, RNA, or Protein
        The second unaligned sequence

    Returns
    -------
    tuple
        ``TabularMSA`` object containing the aligned sequences, alignment score
        (float), and start/end positions of each input sequence (iterable
        of two-item tuples). Note that start/end positions are indexes into the
        unaligned sequences.

    Notes
    -----
    This is a wrapper for the SSW package [1]_.

    For a complete list of optional keyword-arguments that can be provided,
    see ``skbio.alignment.StripedSmithWaterman``.

    The following kwargs will not have any effect: `suppress_sequences`,
    `zero_index`, and `protein`

    If an alignment does not meet a provided filter, `None` will be returned.

    References
    ----------
    .. [1] Zhao, Mengyao, Wan-Ping Lee, Erik P. Garrison, & Gabor T.
       Marth. ""SSW Library: An SIMD Smith-Waterman C/C++ Library for
       Applications"". PLOS ONE (2013). Web. 11 July 2014.
       http://www.plosone.org/article/info:doi/10.1371/journal.pone.0082138

    See Also
    --------
    skbio.alignment.StripedSmithWaterman

    """"""
    for seq in sequence1, sequence2:
        if not isinstance(seq, (DNA, RNA, Protein)):
            raise TypeError(
                ""`sequence1` and `sequence2` must be DNA, RNA, or Protein, ""
                ""not type %r"" % type(seq).__name__)

    if type(sequence1) is not type(sequence2):
        raise TypeError(
            ""`sequence1` and `sequence2` must be the same type: %r != %r""
            % (type(sequence1).__name__, type(sequence2).__name__))

    # We need the sequences for `TabularMSA` to make sense, so don't let the
    # user suppress them.
    kwargs['suppress_sequences'] = False
    kwargs['zero_index'] = True

    kwargs['protein'] = False
    if isinstance(sequence1, Protein):
        kwargs['protein'] = True

    query = StripedSmithWaterman(str(sequence1), **kwargs)
    alignment = query(str(sequence2))

    # If there is no cigar, then it has failed a filter. Return None.
    if not alignment.cigar:
        return None

    start_end = None
    if alignment.query_begin != -1:
        start_end = [
            (alignment.query_begin, alignment.query_end),
            (alignment.target_begin, alignment.target_end_optimal)
        ]

    metadata1 = metadata2 = None
    if sequence1.has_metadata():
        metadata1 = sequence1.metadata
    if sequence2.has_metadata():
        metadata2 = sequence2.metadata

    constructor = type(sequence1)
    msa = TabularMSA([
        constructor(alignment.aligned_query_sequence, metadata=metadata1,
                    validate=False),
        constructor(alignment.aligned_target_sequence, metadata=metadata2,
                    validate=False)
    ])

    return msa, alignment.optimal_alignment_score, start_end",_57.py,46,"'`sequence1` and `sequence2` must be DNA, RNA, or Protein, not type %r' % type(seq).__name__","f'`sequence1` and `sequence2` must be DNA, RNA, or Protein, not type {type(seq).__name__}'",1.0
https://github.com/ponyorm/pony/tree/master/pony/orm/sqltranslation.py,"def aggregate(monad, func_name, distinct=None, sep=None):
        distinct = distinct_from_monad(distinct, default=monad.forced_distinct and func_name in ('SUM', 'AVG'))
        sub = monad.subtranslator
        if sub.aggregated: throw(TranslationError, 'Too complex aggregation in {EXPR}')
        subquery_ast = sub.construct_subquery_ast(distinct=False)
        from_ast, where_ast = subquery_ast[2:4]
        expr_type = sub.expr_type
        if func_name in ('SUM', 'AVG'):
            if expr_type not in numeric_types: throw(TypeError,
                ""Function %s() expects query or items of numeric type, got %r in {EXPR}""
                % (func_name.lower(), type2str(expr_type)))
        elif func_name in ('MIN', 'MAX'):
            if expr_type not in comparable_types: throw(TypeError,
                ""Function %s() cannot be applied to type %r in {EXPR}""
                % (func_name.lower(), type2str(expr_type)))
        elif func_name == 'GROUP_CONCAT':
            if isinstance(expr_type, EntityMeta) and expr_type._pk_is_composite_:
                throw(TypeError, ""`group_concat` cannot be used with entity with composite primary key"")
        else: assert False  # pragma: no cover
        assert len(sub.expr_columns) == 1
        aggr_ast = [ func_name, distinct, sub.expr_columns[0] ]
        if func_name == 'GROUP_CONCAT':
            if sep is not None:
                aggr_ast.append(['VALUE', sep])
        select_ast = [ 'AGGREGATES', aggr_ast ]
        sql_ast = [ 'SELECT', select_ast, from_ast, where_ast ]
        if func_name == 'AVG':
            result_type = float
        elif func_name == 'GROUP_CONCAT':
            result_type = unicode
        else:
            result_type = expr_type
        return ExprMonad.new(result_type, sql_ast, func_name != 'SUM')",_572.py,10,"'Function %s() expects query or items of numeric type, got %r in {EXPR}' % (func_name.lower(), type2str(expr_type))","f'Function {func_name.lower()}() expects query or items of numeric type, got {type2str(expr_type)} in {EXPR}'",1.0
https://github.com/ponyorm/pony/tree/master/pony/orm/sqltranslation.py,"def aggregate(monad, func_name, distinct=None, sep=None):
        distinct = distinct_from_monad(distinct, default=monad.forced_distinct and func_name in ('SUM', 'AVG'))
        sub = monad.subtranslator
        if sub.aggregated: throw(TranslationError, 'Too complex aggregation in {EXPR}')
        subquery_ast = sub.construct_subquery_ast(distinct=False)
        from_ast, where_ast = subquery_ast[2:4]
        expr_type = sub.expr_type
        if func_name in ('SUM', 'AVG'):
            if expr_type not in numeric_types: throw(TypeError,
                ""Function %s() expects query or items of numeric type, got %r in {EXPR}""
                % (func_name.lower(), type2str(expr_type)))
        elif func_name in ('MIN', 'MAX'):
            if expr_type not in comparable_types: throw(TypeError,
                ""Function %s() cannot be applied to type %r in {EXPR}""
                % (func_name.lower(), type2str(expr_type)))
        elif func_name == 'GROUP_CONCAT':
            if isinstance(expr_type, EntityMeta) and expr_type._pk_is_composite_:
                throw(TypeError, ""`group_concat` cannot be used with entity with composite primary key"")
        else: assert False  # pragma: no cover
        assert len(sub.expr_columns) == 1
        aggr_ast = [ func_name, distinct, sub.expr_columns[0] ]
        if func_name == 'GROUP_CONCAT':
            if sep is not None:
                aggr_ast.append(['VALUE', sep])
        select_ast = [ 'AGGREGATES', aggr_ast ]
        sql_ast = [ 'SELECT', select_ast, from_ast, where_ast ]
        if func_name == 'AVG':
            result_type = float
        elif func_name == 'GROUP_CONCAT':
            result_type = unicode
        else:
            result_type = expr_type
        return ExprMonad.new(result_type, sql_ast, func_name != 'SUM')",_572.py,14,"'Function %s() cannot be applied to type %r in {EXPR}' % (func_name.lower(), type2str(expr_type))",f'Function {func_name.lower()}() cannot be applied to type {type2str(expr_type)} in {EXPR}',1.0
https://github.com/LinOTP/LinOTP/tree/master/linotp/lib/security/pkcs11.py,"def unpad(self, padded_byte_str: bytes, block_size: int = 16) -> bytes:
        """"""
        PKCS7 padding pads the missing bytes with the value of the number
        of the bytes. If 4 bytes are missing, this missing bytes are filled
        with \x04

        unpad removes and checks the PKCS #7 padding by verifying that the
        padding byte string only contains the pad chars

        :param padded_byte_str: The binary string to unpad

        :param block_size: Block size

        :raises ValueError: If padded_byte_str is not correctly padded a
            ValueError can be raised.
            This depends on the 'pkcs11.accept_invalid_padding' LinOTP config
            option. If set to False (default) ValueError is raised.  The reason
            why the data is sometimes incorrectly padded is because the pad()
            method delivered with LinOTP version < 2.7.1 didn't pad correctly
            when the data-length was a multiple of the block-length.
            Beware that in some cases (statistically about 0.4% of data-chunks
            whose length is a multiple of the block length) the incorrect
            padding can not be detected and incomplete data is returned.  One
            example for this last case is when the data ends with the byte
            0x01. This is recognized as legitimate padding and is removed
            before returning the data, thus removing a legitimate byte from the
            data and making it unusable.
            If you didn't upgrade from a LinOTP version before 2.7.1 (or don't
            use a PKCS#11 HSM) you will not be affected by this in any way.
            ValueError will of course also be raised if you data became corrupt
            for some other reason (e.g. disk failure) and can not be unpadded.
            In this case you should NOT set 'pkcs11.accept_invalid_padding' to
            True because your data will be unusable anyway.

        :returns: unpadded string or sometimes padded string when
            'pkcs11.accept_invalid_padding' is set to True. See above.
        :rtype: str
        """"""

        last_byte = padded_byte_str[-1]
        padding_length = last_byte

        # ------------------------------------------------------------------ --

        # extract both parts: the unpadded bytes and the padding bytes

        padding_byte_str = padded_byte_str[-padding_length:]
        unpadded_byte_str = padded_byte_str[:-padding_length]

        # ------------------------------------------------------------------ --

        # padding match: verify that the appended padded string contains
        #   only padded value. Therefore compose a string with only
        #   padding bytes and compare it with the truncated padding string

        byte_str_with_padding_byte = (
            ""%s"" % chr(last_byte) * padding_length
        ).encode(""utf-8"")

        padding_match = padding_byte_str == byte_str_with_padding_byte

        # ------------------------------------------------------------------ --

        if 0 < padding_length <= block_size and padding_match:
            return unpadded_byte_str

        elif self.accept_invalid_padding:
            log.warning(""[unpad] Input 'padded_str' is not properly padded"")
            return padded_byte_str

        else:
            raise ValueError(""Input 'padded_str' is not properly padded"")",_580.py,57,'%s' % chr(last_byte),f'{chr(last_byte)}',1.0
https://github.com/openstack/neutron/tree/master/neutron/tests/unit/objects/test_base.py,"def test_update_objects_nothing_to_update(self):
        fields_to_update = self.get_updatable_fields(
            self.obj_fields[1])
        if not fields_to_update:
            self.skipTest('No updatable fields found in test '
                          'class %r' % self._test_class)
        self.assertEqual(
            0, self._test_class.update_objects(self.context, {}))",_606.py,5,'No updatable fields found in test class %r' % self._test_class,f'No updatable fields found in test class {self._test_class}',1.0
https://github.com/imageio/imageio/tree/master/imageio/plugins/_freeimage.py,"def set_meta_data(self, metadata):

        # Create a dict mapping model_name to number
        models = {}
        for name, number in METADATA_MODELS.__dict__.items():
            if name.startswith(""FIMD_""):
                models[name[5:]] = number

        # Create a mapping from numpy.dtype to METADATA_DATATYPE
        def get_tag_type_number(dtype):
            for number, numpy_dtype in METADATA_DATATYPE.dtypes.items():
                if dtype == numpy_dtype:
                    return number
            else:
                return None

        with self._fi as lib:

            for model_name, subdict in metadata.items():

                # Get model number
                number = models.get(model_name, None)
                if number is None:
                    continue  # Unknown model, silent ignore

                for tag_name, tag_val in subdict.items():

                    # Create new tag
                    tag = lib.FreeImage_CreateTag()
                    tag = ctypes.c_void_p(tag)

                    try:
                        # Convert Python value to FI type, val
                        is_ascii = False
                        if isinstance(tag_val, str):
                            try:
                                tag_bytes = tag_val.encode(""ascii"")
                                is_ascii = True
                            except UnicodeError:
                                pass
                        if is_ascii:
                            tag_type = METADATA_DATATYPE.FIDT_ASCII
                            tag_count = len(tag_bytes)
                        else:
                            if not hasattr(tag_val, ""dtype""):
                                tag_val = numpy.array([tag_val])
                            tag_type = get_tag_type_number(tag_val.dtype)
                            if tag_type is None:
                                logger.warning(
                                    ""imageio.freeimage warning: Could not ""
                                    ""determine tag type of %r."" % tag_name
                                )
                                continue
                            tag_bytes = tag_val.tobytes()
                            tag_count = tag_val.size
                        # Set properties
                        lib.FreeImage_SetTagKey(tag, tag_name.encode(""utf-8""))
                        lib.FreeImage_SetTagType(tag, tag_type)
                        lib.FreeImage_SetTagCount(tag, tag_count)
                        lib.FreeImage_SetTagLength(tag, len(tag_bytes))
                        lib.FreeImage_SetTagValue(tag, tag_bytes)
                        # Store tag
                        tag_key = lib.FreeImage_GetTagKey(tag)
                        lib.FreeImage_SetMetadata(number, self._bitmap, tag_key, tag)

                    except Exception as err:  # pragma: no cover
                        logger.warning(
                            ""imagio.freeimage warning: Could not set tag ""
                            ""%r: %s, %s""
                            % (tag_name, self._fi._get_error_message(), str(err))
                        )
                    finally:
                        lib.FreeImage_DeleteTag(tag)",_610.py,68,"'imagio.freeimage warning: Could not set tag %r: %s, %s' % (tag_name, self._fi._get_error_message(), str(err))","f'imagio.freeimage warning: Could not set tag {tag_name}: {self._fi._get_error_message()}, {self._fi._get_error_message()}'",1.0
https://github.com/imageio/imageio/tree/master/imageio/plugins/_freeimage.py,"def set_meta_data(self, metadata):

        # Create a dict mapping model_name to number
        models = {}
        for name, number in METADATA_MODELS.__dict__.items():
            if name.startswith(""FIMD_""):
                models[name[5:]] = number

        # Create a mapping from numpy.dtype to METADATA_DATATYPE
        def get_tag_type_number(dtype):
            for number, numpy_dtype in METADATA_DATATYPE.dtypes.items():
                if dtype == numpy_dtype:
                    return number
            else:
                return None

        with self._fi as lib:

            for model_name, subdict in metadata.items():

                # Get model number
                number = models.get(model_name, None)
                if number is None:
                    continue  # Unknown model, silent ignore

                for tag_name, tag_val in subdict.items():

                    # Create new tag
                    tag = lib.FreeImage_CreateTag()
                    tag = ctypes.c_void_p(tag)

                    try:
                        # Convert Python value to FI type, val
                        is_ascii = False
                        if isinstance(tag_val, str):
                            try:
                                tag_bytes = tag_val.encode(""ascii"")
                                is_ascii = True
                            except UnicodeError:
                                pass
                        if is_ascii:
                            tag_type = METADATA_DATATYPE.FIDT_ASCII
                            tag_count = len(tag_bytes)
                        else:
                            if not hasattr(tag_val, ""dtype""):
                                tag_val = numpy.array([tag_val])
                            tag_type = get_tag_type_number(tag_val.dtype)
                            if tag_type is None:
                                logger.warning(
                                    ""imageio.freeimage warning: Could not ""
                                    ""determine tag type of %r."" % tag_name
                                )
                                continue
                            tag_bytes = tag_val.tobytes()
                            tag_count = tag_val.size
                        # Set properties
                        lib.FreeImage_SetTagKey(tag, tag_name.encode(""utf-8""))
                        lib.FreeImage_SetTagType(tag, tag_type)
                        lib.FreeImage_SetTagCount(tag, tag_count)
                        lib.FreeImage_SetTagLength(tag, len(tag_bytes))
                        lib.FreeImage_SetTagValue(tag, tag_bytes)
                        # Store tag
                        tag_key = lib.FreeImage_GetTagKey(tag)
                        lib.FreeImage_SetMetadata(number, self._bitmap, tag_key, tag)

                    except Exception as err:  # pragma: no cover
                        logger.warning(
                            ""imagio.freeimage warning: Could not set tag ""
                            ""%r: %s, %s""
                            % (tag_name, self._fi._get_error_message(), str(err))
                        )
                    finally:
                        lib.FreeImage_DeleteTag(tag)",_610.py,50,'imageio.freeimage warning: Could not determine tag type of %r.' % tag_name,f'imageio.freeimage warning: Could not determine tag type of {tag_name}.',1.0
https://github.com/ros/ros_comm/tree/master/tools/rosbag/src/rosbag/migration.py,"def apply(self, old_msg):
        if not self.valid:
            raise BagMigrationException(""Attempted to apply an invalid rule"")
        if not self.sub_rules_done:
            raise BagMigrationException(""Attempted to apply a rule without building up its sub rules"")
        if not self.sub_rules_valid:
            raise BagMigrationException(""Attempted to apply a rule without valid sub-rules"")
        if (get_message_key(old_msg) != get_message_key(self.old_class)):
            raise BagMigrationException(""Attempted to apply rule to incorrect class %s %s.""%(get_message_key(old_msg),get_message_key(self.old_class)))

        # Apply update rule
        new_msg = self.new_class()
        self.update(old_msg, new_msg)

        return new_msg",_618.py,9,"'Attempted to apply rule to incorrect class %s %s.' % (get_message_key(old_msg), get_message_key(self.old_class))",f'Attempted to apply rule to incorrect class {get_message_key(old_msg)} {get_message_key(old_msg)}.',1.0
https://github.com/django/django/tree/master/django/core/checks/registry.py,"def run_checks(self, app_configs=None, tags=None, include_deployment_checks=False, databases=None):
        """"""
        Run all registered checks and return list of Errors and Warnings.
        """"""
        errors = []
        checks = self.get_checks(include_deployment_checks)

        if tags is not None:
            checks = [check for check in checks if not set(check.tags).isdisjoint(tags)]

        for check in checks:
            new_errors = check(app_configs=app_configs, databases=databases)
            if not is_iterable(new_errors):
                raise TypeError(
                    'The function %r did not return a list. All functions '
                    'registered with the checks registry must return a list.'
                    % check,
                )
            errors.extend(new_errors)
        return errors",_620.py,15,'The function %r did not return a list. All functions registered with the checks registry must return a list.' % check,f'The function {check} did not return a list. All functions registered with the checks registry must return a list.',1.0
https://github.com/RaRe-Technologies/smart_open/tree/master/smart_open/s3.py,"def __init__(
        self,
        bucket,
        key,
        client=None,
        client_kwargs=None,
        writebuffer=None,
    ):
        _initialize_boto3(self, client, client_kwargs, bucket, key)

        try:
            self._client.head_bucket(Bucket=bucket)
        except botocore.client.ClientError as e:
            raise ValueError('the bucket %r does not exist, or is forbidden for access' % bucket) from e

        if writebuffer is None:
            self._buf = io.BytesIO()
        else:
            self._buf = writebuffer

        self._total_bytes = 0

        #
        # This member is part of the io.BufferedIOBase interface.
        #
        self.raw = None",_625.py,14,"'the bucket %r does not exist, or is forbidden for access' % bucket","f'the bucket {bucket} does not exist, or is forbidden for access'",1.0
https://github.com/ansible/awx/tree/master/awx/sso/middleware.py,"def process_exception(self, request, exception):
        strategy = getattr(request, 'social_strategy', None)
        if strategy is None or self.raise_exception(request, exception):
            return

        if isinstance(exception, SocialAuthBaseException) or request.path.startswith('/sso/'):
            backend = getattr(request, 'backend', None)
            backend_name = getattr(backend, 'name', 'unknown-backend')

            message = self.get_message(request, exception)
            if request.session.get('social_auth_last_backend') != backend_name:
                backend_name = request.session.get('social_auth_last_backend')
                message = request.GET.get('error_description', message)

            full_backend_name = backend_name
            try:
                idp_name = strategy.request_data()['RelayState']
                full_backend_name = '%s:%s' % (backend_name, idp_name)
            except KeyError:
                pass

            social_logger.error(message)

            url = self.get_redirect_uri(request, exception)
            request.session['social_auth_error'] = (full_backend_name, message)
            return redirect(url)",_632.py,18,"'%s:%s' % (backend_name, idp_name)",f'{backend_name}:{backend_name}',1.0
https://github.com/Fantomas42/django-blog-zinnia/tree/master/zinnia/tests/test_templatetags.py,"def test_zinnia_breadcrumbs(self):
        class FakeRequest(object):
            def __init__(self, path):
                self.path = path

        class FakePage(object):
            def __init__(self, number):
                self.number = number

        def check_only_last_have_no_url(crumb_list):
            size = len(crumb_list) - 1
            for i, crumb in enumerate(crumb_list):
                if i != size:
                    self.assertNotEqual(crumb.url, None)
                else:
                    self.assertEqual(crumb.url, None)

        source_context = Context({'request': FakeRequest('/')})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 0)
        self.assertEqual(context['template'], 'zinnia/tags/breadcrumbs.html')

        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context, 'Blog')
        self.assertEqual(len(context['breadcrumbs']), 1)
        self.assertEqual(context['breadcrumbs'][0].name, 'Blog')
        self.assertEqual(context['breadcrumbs'][0].url,
                         reverse('zinnia:entry_archive_index'))
        self.assertEqual(context['template'], 'zinnia/tags/breadcrumbs.html')

        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context,
                                         'Weblog', 'custom_template.html')
        self.assertEqual(len(context['breadcrumbs']), 1)
        self.assertEqual(context['breadcrumbs'][0].name, 'Weblog')
        self.assertEqual(context['template'], 'custom_template.html')

        source_context = Context(
            {'request': FakeRequest(self.entry.get_absolute_url()),
             'object': self.entry})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 4)
        check_only_last_have_no_url(context['breadcrumbs'])

        cat_1 = Category.objects.create(title='Category 1', slug='category-1')
        source_context = Context(
            {'request': FakeRequest(cat_1.get_absolute_url()),
             'object': cat_1})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 2)
        check_only_last_have_no_url(context['breadcrumbs'])
        cat_2 = Category.objects.create(title='Category 2', slug='category-2',
                                        parent=cat_1)
        source_context = Context(
            {'request': FakeRequest(cat_2.get_absolute_url()),
             'object': cat_2})
        with self.assertNumQueries(1):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 3)
        check_only_last_have_no_url(context['breadcrumbs'])

        tag = Tag.objects.get(name='test')
        source_context = Context(
            {'request': FakeRequest(reverse('zinnia:tag_detail',
                                            args=['test'])),
             'object': tag})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 2)
        check_only_last_have_no_url(context['breadcrumbs'])

        author = Author.objects.create_user(username='webmaster',
                                            email='webmaster@example.com')
        source_context = Context(
            {'request': FakeRequest(author.get_absolute_url()),
             'object': author})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 2)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context(
            {'request': FakeRequest(reverse(
                'zinnia:entry_archive_year', args=[2011]))})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 1)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest(reverse(
            'zinnia:entry_archive_month', args=[2011, '03']))})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 2)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest(reverse(
            'zinnia:entry_archive_week', args=[2011, 15]))})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 2)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest(reverse(
            'zinnia:entry_archive_day', args=[2011, '03', 15]))})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 3)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest('%s?page=2' % reverse(
            'zinnia:entry_archive_day', args=[2011, '03', 15])),
            'page_obj': FakePage(2)})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 4)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest(reverse(
            'zinnia:entry_archive_day_paginated', args=[2011, '03', 15, 2])),
            'page_obj': FakePage(2)})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 4)
        check_only_last_have_no_url(context['breadcrumbs'])

        source_context = Context({'request': FakeRequest('/url/')})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 1)
        self.assertEqual(context['breadcrumbs'][0].name, 'Url')
        self.assertEqual(context['breadcrumbs'][0].url, None)

        source_context = Context({'request': FakeRequest('/url/path/')})
        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context)
        self.assertEqual(len(context['breadcrumbs']), 1)
        self.assertEqual(context['breadcrumbs'][0].name, 'Path')
        self.assertEqual(context['breadcrumbs'][0].url, None)

        with self.assertNumQueries(0):
            context = zinnia_breadcrumbs(source_context, 'Root')
        self.assertEqual(len(context['breadcrumbs']), 2)
        self.assertEqual(context['breadcrumbs'][0].name, 'Root')
        self.assertEqual(context['breadcrumbs'][0].url,
                         reverse('zinnia:entry_archive_index'))
        self.assertEqual(context['breadcrumbs'][1].name, 'Path')
        self.assertEqual(context['breadcrumbs'][1].url, None)",_634.py,114,"'%s?page=2' % reverse('zinnia:entry_archive_day', args=[2011, '03', 15])","f""{reverse('zinnia:entry_archive_day', args=[2011, '03', 15])}?page=2""",1.0
https://github.com/dbr/tvnamer/tree/master/tvnamer/data.py,"def number_string(self):
        # type: () -> str
        """"""Used in UI
        """"""
        return ""season: %s, episode: %s"" % (
            self.seasonnumber,
            "", "".join([str(x) for x in self.episodenumbers]),
        )",_645.py,5,"'season: %s, episode: %s' % (self.seasonnumber, ', '.join([str(x) for x in self.episodenumbers]))","f'season: {self.seasonnumber}, episode: {self.seasonnumber}'",1.0
https://github.com/3b1b/videos/tree/master/_2017/eoc/chapter6.py,"def show_dx_dy_step(self):
        dot = self.example_point_dot
        s_label = self.example_point_label
        rhs = s_label[-1]
        s_label.remove(rhs)

        point = dot.get_center()
        vect = 2*LEFT + DOWN
        new_point = point + vect*0.6/self.zoom_factor
        interim_point = new_point[0]*RIGHT + point[1]*UP

        dx_line = Line(point, interim_point, color = GREEN)
        dy_line = Line(interim_point, new_point, color = RED)
        for line, tex, vect in (dx_line, ""dx"", UP), (dy_line, ""dy"", LEFT):
            label = Tex(tex)
            label.set_color(line.get_color())
            label.next_to(line, vect, buff = SMALL_BUFF)
            label.add_background_rectangle()
            label.scale(
                1./self.zoom_factor, 
                about_point = line.get_center()
            )
            line.label = label

        self.activate_zooming()
        lil_rect = self.little_rectangle        
        lil_rect.move_to(dot)
        lil_rect.shift(0.05*lil_rect.get_width()*LEFT)
        lil_rect.shift(0.2*lil_rect.get_height()*DOWN)
        lil_rect.save_state()
        lil_rect.set_height(FRAME_Y_RADIUS - MED_LARGE_BUFF)
        lil_rect.move_to(s_label, UP)
        lil_rect.shift(MED_SMALL_BUFF*UP)
        self.wait()
        self.play(
            FadeOut(rhs),
            dot.scale, 1./self.zoom_factor, point,
            s_label.scale, 1./self.zoom_factor, point,
            lil_rect.restore,
            run_time = 2
        )
        self.wait()
        for line in dx_line, dy_line:
            self.play(ShowCreation(line))
            self.play(Write(line.label, run_time = 1))
            self.wait()

        new_dot = Dot(color = dot.get_color())
        new_s_label = self.get_s_expression(
            ""%d + dx""%int(self.example_point[0]),
            ""%d + dy""%int(self.example_point[1]),
        )
        new_dot.set_height(dot.get_height())
        new_dot.move_to(new_point)
        new_s_label.set_height(s_label.get_height())
        new_s_label.scale(0.8)
        new_s_label.next_to(
            new_dot, DOWN, 
            buff = SMALL_BUFF/self.zoom_factor, 
            aligned_edge = LEFT
        )
        new_s_label.shift(MED_LARGE_BUFF*LEFT/self.zoom_factor)
        new_s_label.set_color(self.example_color)
        VGroup(*new_s_label[1][1][3:5]).set_color(GREEN)
        VGroup(*new_s_label[1][1][-3:-1]).set_color(RED)

        self.play(ShowCreation(new_dot))
        self.play(Write(new_s_label))
        self.wait()

        ds = self.derivative[1][0]
        self.play(FocusOn(ds))
        self.play(Indicate(ds))
        self.wait()

        self.tiny_step_group = VGroup(
            dx_line, dx_line.label,
            dy_line, dy_line.label,
            s_label, new_s_label, new_dot
        )",_647.py,50,'%d + dx' % int(self.example_point[0]),f'{int(self.example_point[0])} + dx',1.0
https://github.com/3b1b/videos/tree/master/_2017/eoc/chapter6.py,"def show_dx_dy_step(self):
        dot = self.example_point_dot
        s_label = self.example_point_label
        rhs = s_label[-1]
        s_label.remove(rhs)

        point = dot.get_center()
        vect = 2*LEFT + DOWN
        new_point = point + vect*0.6/self.zoom_factor
        interim_point = new_point[0]*RIGHT + point[1]*UP

        dx_line = Line(point, interim_point, color = GREEN)
        dy_line = Line(interim_point, new_point, color = RED)
        for line, tex, vect in (dx_line, ""dx"", UP), (dy_line, ""dy"", LEFT):
            label = Tex(tex)
            label.set_color(line.get_color())
            label.next_to(line, vect, buff = SMALL_BUFF)
            label.add_background_rectangle()
            label.scale(
                1./self.zoom_factor, 
                about_point = line.get_center()
            )
            line.label = label

        self.activate_zooming()
        lil_rect = self.little_rectangle        
        lil_rect.move_to(dot)
        lil_rect.shift(0.05*lil_rect.get_width()*LEFT)
        lil_rect.shift(0.2*lil_rect.get_height()*DOWN)
        lil_rect.save_state()
        lil_rect.set_height(FRAME_Y_RADIUS - MED_LARGE_BUFF)
        lil_rect.move_to(s_label, UP)
        lil_rect.shift(MED_SMALL_BUFF*UP)
        self.wait()
        self.play(
            FadeOut(rhs),
            dot.scale, 1./self.zoom_factor, point,
            s_label.scale, 1./self.zoom_factor, point,
            lil_rect.restore,
            run_time = 2
        )
        self.wait()
        for line in dx_line, dy_line:
            self.play(ShowCreation(line))
            self.play(Write(line.label, run_time = 1))
            self.wait()

        new_dot = Dot(color = dot.get_color())
        new_s_label = self.get_s_expression(
            ""%d + dx""%int(self.example_point[0]),
            ""%d + dy""%int(self.example_point[1]),
        )
        new_dot.set_height(dot.get_height())
        new_dot.move_to(new_point)
        new_s_label.set_height(s_label.get_height())
        new_s_label.scale(0.8)
        new_s_label.next_to(
            new_dot, DOWN, 
            buff = SMALL_BUFF/self.zoom_factor, 
            aligned_edge = LEFT
        )
        new_s_label.shift(MED_LARGE_BUFF*LEFT/self.zoom_factor)
        new_s_label.set_color(self.example_color)
        VGroup(*new_s_label[1][1][3:5]).set_color(GREEN)
        VGroup(*new_s_label[1][1][-3:-1]).set_color(RED)

        self.play(ShowCreation(new_dot))
        self.play(Write(new_s_label))
        self.wait()

        ds = self.derivative[1][0]
        self.play(FocusOn(ds))
        self.play(Indicate(ds))
        self.wait()

        self.tiny_step_group = VGroup(
            dx_line, dx_line.label,
            dy_line, dy_line.label,
            s_label, new_s_label, new_dot
        )",_647.py,51,'%d + dy' % int(self.example_point[1]),f'{int(self.example_point[1])} + dy',1.0
https://github.com/ansible/ansible-modules-extras/tree/master/cloud/rackspace/rax_mon_check.py,"def cloud_check(module, state, entity_id, label, check_type,
                monitoring_zones_poll, target_hostname, target_alias, details,
                disabled, metadata, period, timeout):

    # Coerce attributes.

    if monitoring_zones_poll and not isinstance(monitoring_zones_poll, list):
        monitoring_zones_poll = [monitoring_zones_poll]

    if period:
        period = int(period)

    if timeout:
        timeout = int(timeout)

    changed = False
    check = None

    cm = pyrax.cloud_monitoring
    if not cm:
        module.fail_json(msg='Failed to instantiate client. This typically '
                             'indicates an invalid region or an incorrectly '
                             'capitalized region name.')

    entity = cm.get_entity(entity_id)
    if not entity:
        module.fail_json(msg='Failed to instantiate entity. ""%s"" may not be'
                             ' a valid entity id.' % entity_id)

    existing = [e for e in entity.list_checks() if e.label == label]

    if existing:
        check = existing[0]

    if state == 'present':
        if len(existing) > 1:
            module.fail_json(msg='%s existing checks have a label of %s.' %
                                 (len(existing), label))

        should_delete = False
        should_create = False
        should_update = False

        if check:
            # Details may include keys set to default values that are not
            # included in the initial creation.
            #
            # Only force a recreation of the check if one of the *specified*
            # keys is missing or has a different value.
            if details:
                for (key, value) in details.iteritems():
                    if key not in check.details:
                        should_delete = should_create = True
                    elif value != check.details[key]:
                        should_delete = should_create = True

            should_update = label != check.label or \
                (target_hostname and target_hostname != check.target_hostname) or \
                (target_alias and target_alias != check.target_alias) or \
                (disabled != check.disabled) or \
                (metadata and metadata != check.metadata) or \
                (period and period != check.period) or \
                (timeout and timeout != check.timeout) or \
                (monitoring_zones_poll and monitoring_zones_poll != check.monitoring_zones_poll)

            if should_update and not should_delete:
                check.update(label=label,
                             disabled=disabled,
                             metadata=metadata,
                             monitoring_zones_poll=monitoring_zones_poll,
                             timeout=timeout,
                             period=period,
                             target_alias=target_alias,
                             target_hostname=target_hostname)
                changed = True
        else:
            # The check doesn't exist yet.
            should_create = True

        if should_delete:
            check.delete()

        if should_create:
            check = cm.create_check(entity,
                                    label=label,
                                    check_type=check_type,
                                    target_hostname=target_hostname,
                                    target_alias=target_alias,
                                    monitoring_zones_poll=monitoring_zones_poll,
                                    details=details,
                                    disabled=disabled,
                                    metadata=metadata,
                                    period=period,
                                    timeout=timeout)
            changed = True
    elif state == 'absent':
        if check:
            check.delete()
            changed = True
    else:
        module.fail_json(msg='state must be either present or absent.')

    if check:
        check_dict = {
            ""id"": check.id,
            ""label"": check.label,
            ""type"": check.type,
            ""target_hostname"": check.target_hostname,
            ""target_alias"": check.target_alias,
            ""monitoring_zones_poll"": check.monitoring_zones_poll,
            ""details"": check.details,
            ""disabled"": check.disabled,
            ""metadata"": check.metadata,
            ""period"": check.period,
            ""timeout"": check.timeout
        }
        module.exit_json(changed=changed, check=check_dict)
    else:
        module.exit_json(changed=changed)",_653.py,27,"'Failed to instantiate entity. ""%s"" may not be a valid entity id.' % entity_id","f'Failed to instantiate entity. ""{entity_id}"" may not be a valid entity id.'",1.0
https://github.com/ansible/ansible-modules-extras/tree/master/cloud/rackspace/rax_mon_check.py,"def cloud_check(module, state, entity_id, label, check_type,
                monitoring_zones_poll, target_hostname, target_alias, details,
                disabled, metadata, period, timeout):

    # Coerce attributes.

    if monitoring_zones_poll and not isinstance(monitoring_zones_poll, list):
        monitoring_zones_poll = [monitoring_zones_poll]

    if period:
        period = int(period)

    if timeout:
        timeout = int(timeout)

    changed = False
    check = None

    cm = pyrax.cloud_monitoring
    if not cm:
        module.fail_json(msg='Failed to instantiate client. This typically '
                             'indicates an invalid region or an incorrectly '
                             'capitalized region name.')

    entity = cm.get_entity(entity_id)
    if not entity:
        module.fail_json(msg='Failed to instantiate entity. ""%s"" may not be'
                             ' a valid entity id.' % entity_id)

    existing = [e for e in entity.list_checks() if e.label == label]

    if existing:
        check = existing[0]

    if state == 'present':
        if len(existing) > 1:
            module.fail_json(msg='%s existing checks have a label of %s.' %
                                 (len(existing), label))

        should_delete = False
        should_create = False
        should_update = False

        if check:
            # Details may include keys set to default values that are not
            # included in the initial creation.
            #
            # Only force a recreation of the check if one of the *specified*
            # keys is missing or has a different value.
            if details:
                for (key, value) in details.iteritems():
                    if key not in check.details:
                        should_delete = should_create = True
                    elif value != check.details[key]:
                        should_delete = should_create = True

            should_update = label != check.label or \
                (target_hostname and target_hostname != check.target_hostname) or \
                (target_alias and target_alias != check.target_alias) or \
                (disabled != check.disabled) or \
                (metadata and metadata != check.metadata) or \
                (period and period != check.period) or \
                (timeout and timeout != check.timeout) or \
                (monitoring_zones_poll and monitoring_zones_poll != check.monitoring_zones_poll)

            if should_update and not should_delete:
                check.update(label=label,
                             disabled=disabled,
                             metadata=metadata,
                             monitoring_zones_poll=monitoring_zones_poll,
                             timeout=timeout,
                             period=period,
                             target_alias=target_alias,
                             target_hostname=target_hostname)
                changed = True
        else:
            # The check doesn't exist yet.
            should_create = True

        if should_delete:
            check.delete()

        if should_create:
            check = cm.create_check(entity,
                                    label=label,
                                    check_type=check_type,
                                    target_hostname=target_hostname,
                                    target_alias=target_alias,
                                    monitoring_zones_poll=monitoring_zones_poll,
                                    details=details,
                                    disabled=disabled,
                                    metadata=metadata,
                                    period=period,
                                    timeout=timeout)
            changed = True
    elif state == 'absent':
        if check:
            check.delete()
            changed = True
    else:
        module.fail_json(msg='state must be either present or absent.')

    if check:
        check_dict = {
            ""id"": check.id,
            ""label"": check.label,
            ""type"": check.type,
            ""target_hostname"": check.target_hostname,
            ""target_alias"": check.target_alias,
            ""monitoring_zones_poll"": check.monitoring_zones_poll,
            ""details"": check.details,
            ""disabled"": check.disabled,
            ""metadata"": check.metadata,
            ""period"": check.period,
            ""timeout"": check.timeout
        }
        module.exit_json(changed=changed, check=check_dict)
    else:
        module.exit_json(changed=changed)",_653.py,37,"'%s existing checks have a label of %s.' % (len(existing), label)",f'{len(existing)} existing checks have a label of {len(existing)}.',1.0
https://github.com/Scifabric/pybossa/tree/master/pybossa/hateoas.py,"def create_link(self, item_id, title, rel='self'):
        """"""Create hateoas link.""""""
        # title = item.__class__.__name__.lower()
        method = "".api_%s"" % title
        href = url_for(method, oid=item_id, _external=True)
        return self.link(rel, title, href)",_684.py,4,'.api_%s' % title,f'.api_{title}',1.0
https://github.com/geek-ai/MAgent/tree/master/examples/train_single.py,"if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--save_every"", type=int, default=5)
    parser.add_argument(""--render_every"", type=int, default=10)
    parser.add_argument(""--n_round"", type=int, default=2000)
    parser.add_argument(""--render"", action=""store_true"")
    parser.add_argument(""--load_from"", type=int)
    parser.add_argument(""--train"", action=""store_true"")
    parser.add_argument(""--map_size"", type=int, default=125)
    parser.add_argument(""--greedy"", action=""store_true"")
    parser.add_argument(""--name"", type=str, default=""battle"")
    parser.add_argument(""--eval"", action=""store_true"")
    parser.add_argument('--alg', default='dqn', choices=['dqn', 'drqn'])
    args = parser.parse_args()

    # set logger
    log.basicConfig(level=log.INFO, filename=args.name + '.log')
    console = log.StreamHandler()
    console.setLevel(log.INFO)
    log.getLogger('').addHandler(console)

    # init the game
    env = magent.GridWorld(""battle"", map_size=args.map_size)
    env.set_render_dir(""build/render"")

    # two groups of agents
    handles = env.get_handles()
    
    # sample eval observation set
    eval_obs = None
    if args.eval:
        print(""sample eval set..."")
        env.reset()
        generate_map(env, args.map_size, handles)
        eval_obs = magent.utility.sample_observation(env, handles, 2048, 500)[0]

    # init models
    batch_size = 512
    unroll_step = 8
    target_update = 1200
    train_freq = 5

    models = []
    if args.alg == 'dqn':
        from magent.builtin.tf_model import DeepQNetwork
        models.append(DeepQNetwork(env, handles[0], args.name,
                                   batch_size=batch_size,
                                   learning_rate=3e-4,
                                   memory_size=2 ** 21, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    elif args.alg == 'drqn':
        from magent.builtin.tf_model import DeepRecurrentQNetwork
        models.append(DeepRecurrentQNetwork(env, handles[0], args.name,
                                   learning_rate=3e-4,
                                   batch_size=batch_size/unroll_step, unroll_step=unroll_step,
                                   memory_size=2 * 8 * 625, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    else:
        # see train_against.py to know how to use a2c
        raise NotImplementedError

    models.append(models[0])

    # load if
    savedir = 'save_model'
    if args.load_from is not None:
        start_from = args.load_from
        print(""load ... %d"" % start_from)
        for model in models:
            model.load(savedir, start_from)
    else:
        start_from = 0

    # print debug info
    print(args)
    print(""view_space"", env.get_view_space(handles[0]))
    print(""feature_space"", env.get_feature_space(handles[0]))

    # play
    start = time.time()
    for k in range(start_from, start_from + args.n_round):
        tic = time.time()
        eps = magent.utility.piecewise_decay(k, [0, 700, 1400], [1, 0.2, 0.05]) if not args.greedy else 0
        loss, num, reward, value = play_a_round(env, args.map_size, handles, models,
                                                train=args.train, print_every=50,
                                                render=args.render or (k+1) % args.render_every == 0,
                                                eps=eps)  # for e-greedy

        log.info(""round %d\t loss: %s\t num: %s\t reward: %s\t value: %s"" % (k, loss, num, reward, value))
        print(""round time %.2f  total time %.2f\n"" % (time.time() - tic, time.time() - start))

        # save models
        if (k + 1) % args.save_every == 0 and args.train:
            print(""save model... "")
            for model in models:
                model.save(savedir, k)",_688.py,68,'load ... %d' % start_from,f'load ... {start_from}',1.0
https://github.com/geek-ai/MAgent/tree/master/examples/train_single.py,"if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--save_every"", type=int, default=5)
    parser.add_argument(""--render_every"", type=int, default=10)
    parser.add_argument(""--n_round"", type=int, default=2000)
    parser.add_argument(""--render"", action=""store_true"")
    parser.add_argument(""--load_from"", type=int)
    parser.add_argument(""--train"", action=""store_true"")
    parser.add_argument(""--map_size"", type=int, default=125)
    parser.add_argument(""--greedy"", action=""store_true"")
    parser.add_argument(""--name"", type=str, default=""battle"")
    parser.add_argument(""--eval"", action=""store_true"")
    parser.add_argument('--alg', default='dqn', choices=['dqn', 'drqn'])
    args = parser.parse_args()

    # set logger
    log.basicConfig(level=log.INFO, filename=args.name + '.log')
    console = log.StreamHandler()
    console.setLevel(log.INFO)
    log.getLogger('').addHandler(console)

    # init the game
    env = magent.GridWorld(""battle"", map_size=args.map_size)
    env.set_render_dir(""build/render"")

    # two groups of agents
    handles = env.get_handles()
    
    # sample eval observation set
    eval_obs = None
    if args.eval:
        print(""sample eval set..."")
        env.reset()
        generate_map(env, args.map_size, handles)
        eval_obs = magent.utility.sample_observation(env, handles, 2048, 500)[0]

    # init models
    batch_size = 512
    unroll_step = 8
    target_update = 1200
    train_freq = 5

    models = []
    if args.alg == 'dqn':
        from magent.builtin.tf_model import DeepQNetwork
        models.append(DeepQNetwork(env, handles[0], args.name,
                                   batch_size=batch_size,
                                   learning_rate=3e-4,
                                   memory_size=2 ** 21, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    elif args.alg == 'drqn':
        from magent.builtin.tf_model import DeepRecurrentQNetwork
        models.append(DeepRecurrentQNetwork(env, handles[0], args.name,
                                   learning_rate=3e-4,
                                   batch_size=batch_size/unroll_step, unroll_step=unroll_step,
                                   memory_size=2 * 8 * 625, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    else:
        # see train_against.py to know how to use a2c
        raise NotImplementedError

    models.append(models[0])

    # load if
    savedir = 'save_model'
    if args.load_from is not None:
        start_from = args.load_from
        print(""load ... %d"" % start_from)
        for model in models:
            model.load(savedir, start_from)
    else:
        start_from = 0

    # print debug info
    print(args)
    print(""view_space"", env.get_view_space(handles[0]))
    print(""feature_space"", env.get_feature_space(handles[0]))

    # play
    start = time.time()
    for k in range(start_from, start_from + args.n_round):
        tic = time.time()
        eps = magent.utility.piecewise_decay(k, [0, 700, 1400], [1, 0.2, 0.05]) if not args.greedy else 0
        loss, num, reward, value = play_a_round(env, args.map_size, handles, models,
                                                train=args.train, print_every=50,
                                                render=args.render or (k+1) % args.render_every == 0,
                                                eps=eps)  # for e-greedy

        log.info(""round %d\t loss: %s\t num: %s\t reward: %s\t value: %s"" % (k, loss, num, reward, value))
        print(""round time %.2f  total time %.2f\n"" % (time.time() - tic, time.time() - start))

        # save models
        if (k + 1) % args.save_every == 0 and args.train:
            print(""save model... "")
            for model in models:
                model.save(savedir, k)",_688.py,89,"'round %d\t loss: %s\t num: %s\t reward: %s\t value: %s' % (k, loss, num, reward, value)",f'round {k}\t loss: {loss}\t num: {loss}\t reward: {loss}\t value: {loss}',1.0
https://github.com/geek-ai/MAgent/tree/master/examples/train_single.py,"if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--save_every"", type=int, default=5)
    parser.add_argument(""--render_every"", type=int, default=10)
    parser.add_argument(""--n_round"", type=int, default=2000)
    parser.add_argument(""--render"", action=""store_true"")
    parser.add_argument(""--load_from"", type=int)
    parser.add_argument(""--train"", action=""store_true"")
    parser.add_argument(""--map_size"", type=int, default=125)
    parser.add_argument(""--greedy"", action=""store_true"")
    parser.add_argument(""--name"", type=str, default=""battle"")
    parser.add_argument(""--eval"", action=""store_true"")
    parser.add_argument('--alg', default='dqn', choices=['dqn', 'drqn'])
    args = parser.parse_args()

    # set logger
    log.basicConfig(level=log.INFO, filename=args.name + '.log')
    console = log.StreamHandler()
    console.setLevel(log.INFO)
    log.getLogger('').addHandler(console)

    # init the game
    env = magent.GridWorld(""battle"", map_size=args.map_size)
    env.set_render_dir(""build/render"")

    # two groups of agents
    handles = env.get_handles()
    
    # sample eval observation set
    eval_obs = None
    if args.eval:
        print(""sample eval set..."")
        env.reset()
        generate_map(env, args.map_size, handles)
        eval_obs = magent.utility.sample_observation(env, handles, 2048, 500)[0]

    # init models
    batch_size = 512
    unroll_step = 8
    target_update = 1200
    train_freq = 5

    models = []
    if args.alg == 'dqn':
        from magent.builtin.tf_model import DeepQNetwork
        models.append(DeepQNetwork(env, handles[0], args.name,
                                   batch_size=batch_size,
                                   learning_rate=3e-4,
                                   memory_size=2 ** 21, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    elif args.alg == 'drqn':
        from magent.builtin.tf_model import DeepRecurrentQNetwork
        models.append(DeepRecurrentQNetwork(env, handles[0], args.name,
                                   learning_rate=3e-4,
                                   batch_size=batch_size/unroll_step, unroll_step=unroll_step,
                                   memory_size=2 * 8 * 625, target_update=target_update,
                                   train_freq=train_freq, eval_obs=eval_obs))
    else:
        # see train_against.py to know how to use a2c
        raise NotImplementedError

    models.append(models[0])

    # load if
    savedir = 'save_model'
    if args.load_from is not None:
        start_from = args.load_from
        print(""load ... %d"" % start_from)
        for model in models:
            model.load(savedir, start_from)
    else:
        start_from = 0

    # print debug info
    print(args)
    print(""view_space"", env.get_view_space(handles[0]))
    print(""feature_space"", env.get_feature_space(handles[0]))

    # play
    start = time.time()
    for k in range(start_from, start_from + args.n_round):
        tic = time.time()
        eps = magent.utility.piecewise_decay(k, [0, 700, 1400], [1, 0.2, 0.05]) if not args.greedy else 0
        loss, num, reward, value = play_a_round(env, args.map_size, handles, models,
                                                train=args.train, print_every=50,
                                                render=args.render or (k+1) % args.render_every == 0,
                                                eps=eps)  # for e-greedy

        log.info(""round %d\t loss: %s\t num: %s\t reward: %s\t value: %s"" % (k, loss, num, reward, value))
        print(""round time %.2f  total time %.2f\n"" % (time.time() - tic, time.time() - start))

        # save models
        if (k + 1) % args.save_every == 0 and args.train:
            print(""save model... "")
            for model in models:
                model.save(savedir, k)",_688.py,90,"'round time %.2f  total time %.2f\n' % (time.time() - tic, time.time() - start)",f'round time {time.time() - tic}  total time {time.time() - tic}\n',1.0
https://github.com/athena-team/athena/tree/master/athena/utils/hparam.py,"def _get_kind_name(param_type, is_list):
        """"""Returns the field name given parameter type and is_list.

        Args:
            param_type: Data type of the hparam.
            is_list: Whether this is a list.

        Returns:
            A string representation of the field name.

        Raises:
            ValueError: If parameter type is not recognized.
        """"""
        if issubclass(param_type, bool):
            # This check must happen before issubclass(param_type, six.integer_types),
            # since Python considers bool to be a subclass of int.
            typename = ""bool""
        elif issubclass(param_type, six.integer_types):
            # Setting 'int' and 'long' types to be 'int64' to ensure the type is
            # compatible with both Python2 and Python3.
            typename = ""int64""
        elif issubclass(param_type, (six.string_types, six.binary_type)):
            # Setting 'string' and 'bytes' types to be 'bytes' to ensure the type is
            # compatible with both Python2 and Python3.
            typename = ""bytes""
        elif issubclass(param_type, float):
            typename = ""float""
        else:
            raise ValueError(""Unsupported parameter type: %s"" % str(param_type))

        suffix = ""list"" if is_list else ""value""
        return ""_"".join([typename, suffix])",_702.py,29,'Unsupported parameter type: %s' % str(param_type),f'Unsupported parameter type: {str(param_type)}',1.0
https://github.com/openstack/horizon/tree/master/openstack_dashboard/dashboards/project/instances/tables.py,"def single(self, table, request, obj_id):
        instance = table.get_object_by_id(obj_id)
        try:
            api.nova.server_revert_resize(request, instance.id)
        except Exception:
            exceptions.handle(request,
                              _('Unable to revert resize instance ""%s"".')
                              % (instance.name or instance.id))",_730.py,7,"exceptions.handle(request, _('Unable to revert resize instance ""%s"".') % (instance.name or instance.id))","_('Unable to revert resize instance ""%s"".') % (instance.name or instance.id)",1
https://github.com/openstack/horizon/tree/master/openstack_dashboard/dashboards/project/networks/subnets/tests.py,"def test_subnet_update_post_invalid_routes_three_entries(self):
        host_routes = 'aaaa,bbbb,cccc'
        res = self._test_subnet_update_post_invalid(host_routes)
        self.assertContains(res,
                            'Host Routes format error: '
                            'Destination CIDR and nexthop must be specified '
                            '(value=%s)' % host_routes)",_770.py,5,'Host Routes format error: Destination CIDR and nexthop must be specified (value=%s)' % host_routes,f'Host Routes format error: Destination CIDR and nexthop must be specified (value={host_routes})',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,489,"'merlin_dir=""%s""' % merlin_dir","f'merlin_dir=""{merlin_dir}""'",1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,497,"'wav_dir=""%s""' % (experiment_dir + '/database/wav')","f'''wav_dir=""{experiment_dir + '/database/wav'}""'''",1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,115,'FESTDIR=%s\n' % festdir,f'FESTDIR={festdir}\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,124,'HTKDIR=%s\n' % htkdir,f'HTKDIR={htkdir}\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,429,'bash -x scripts/prepare_config_files.sh %s 2>&1' % global_config_file,f'bash -x scripts/prepare_config_files.sh {global_config_file} 2>&1',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,430,'bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1' % global_config_file,f'bash -x scripts/prepare_config_files_for_synthesis.sh {global_config_file} 2>&1',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,509,"'Audio features in %s (and %s)' % (os.getcwd() + '/audio_feat', merlin_dir + '/egs/slt_arctic/s1/slt_arctic_full_data/feat')","f""Audio features in {os.getcwd() + '/audio_feat'} (and {os.getcwd() + '/audio_feat'})""",1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,511,"'Text features in %s (and %s)' % (os.getcwd() + '/text_feat', merlin_dir + '/misc/scripts/alignment/phone_align/full-context-labels/full')","f""Text features in {os.getcwd() + '/text_feat'} (and {os.getcwd() + '/text_feat'})""",1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,67,"'for i in *.wav; do echo %s; %s; mv tmp_$i $i; done' % (convert, convert)",f'for i in *.wav; do echo {convert}; {convert}; mv tmp_$i $i; done',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,146,'ESTDIR=%s\n' % estdir,f'ESTDIR={estdir}\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,156,'FESTDIR=%s\n' % festdir,f'FESTDIR={festdir}\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,165,'FESTVOXDIR=%s\n' % festvoxdir,f'FESTVOXDIR={festvoxdir}\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,45,"'Unable to find any wav files in %s, make sure the filenames end in .wav!' % wav_partial_path","f'Unable to find any wav files in {wav_partial_path}, make sure the filenames end in .wav!'",1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,51,"'echo %s; cp %s .' % (fi, fi)",f'echo {fi}; cp {fi} .',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,84,'Unable to find any txt files in %s. Be sure the filenames end in .txt!' % txt_partial_path,f'Unable to find any txt files in {txt_partial_path}. Be sure the filenames end in .txt!',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,243,"'cp %s %s/txt.done.data' % (out_path, latest_feature_dir)",f'cp {out_path} {out_path}/txt.done.data',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,367,'    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n' % str(max_n_itr),f'    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 {str(max_n_itr)} $num_cpus\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,385,'./bin/%s build_prompts\n' % dbn,f'./bin/{dbn} build_prompts\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,392,'./bin/%s label\n' % dbn,f'./bin/{dbn} label\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,399,'./bin/%s build_utts\n' % dbn,f'./bin/{dbn} build_utts\n',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,90,"'echo %s; cp %s .' % (fi, fi)",f'echo {fi}; cp {fi} .',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,214,'Processing %s' % txtpath,f'Processing {txtpath}',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,300,'%s/src/clustergen/setup_cg cmu us slt_arctic' % festvoxdir,f'{festvoxdir}/src/clustergen/setup_cg cmu us slt_arctic',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,273,"'echo %s; cp %s .' % (fi, fi)",f'echo {fi}; cp {fi} .',1.0
https://github.com/r9y9/deepvoice3_pytorch/tree/master/vctk_preprocess/extract_feats.py,"def extract_intermediate_features(wav_path, txt_path, keep_silences=False,
                                  full_features=False, ehmm_max_n_itr=1):
    basedir = os.getcwd()
    latest_feature_dir = ""latest_features""
    if not os.path.exists(latest_feature_dir):
        os.mkdir(latest_feature_dir)

    os.chdir(latest_feature_dir)
    latest_feature_dir = os.getcwd()

    if not os.path.exists(""merlin""):
        clone_cmd = ""git clone https://github.com/kastnerkyle/merlin""
        pe(clone_cmd, shell=True)

    if keep_silences:
        # REMOVE SILENCES TO MATCH JOSE PREPROC
        os.chdir(""merlin/src"")
        pe(""sed -i.bak -e '708,712d;' run_merlin.py"", shell=True)
        pe(""sed -i.bak -e '695,706d;' run_merlin.py"", shell=True)
        os.chdir(latest_feature_dir)

    os.chdir(""merlin"")
    merlin_dir = os.getcwd()
    os.chdir(""egs/build_your_own_voice/s1"")
    experiment_dir = os.getcwd()

    if not os.path.exists(""database""):
        print(""Creating database and copying in files"")
        pe(""bash -x 01_setup.sh my_new_voice 2>&1"", shell=True)

        # Copy in wav files
        wav_partial_path = wav_path  # vctkdir + ""wav48/""
        """"""
        subfolders = sorted(os.listdir(wav_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/wav"")
        for sf in subfolders:
            wav_path = wav_partial_path + sf + ""/*.wav""
            pe(""cp %s ."" % wav_path, shell=True)
        """"""
        to_copy = os.listdir(wav_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".wav""]) == 0:
            raise IOError(
                ""Unable to find any wav files in %s, make sure the filenames end in .wav!"" % wav_partial_path)
        os.chdir(""database/wav"")
        if wav_partial_path[-1] != ""/"":
            wav_partial_path = wav_partial_path + ""/""
        wav_match_path = wav_partial_path + ""*.wav""
        for fi in glob.glob(wav_match_path):
            pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
        # THIS MAY FAIL IF TOO MANY WAV FILES
        # pe(""cp %s ."" % wav_match_path, shell=True)
        for f in os.listdir("".""):
            # This is only necessary because of corrupted files...
            fs, d = wavfile.read(f)
            wavfile.write(f, fs, d)

        # downsample the files
        get_sr_cmd = 'file `ls *.wav | head -n 1` | cut -d "" "" -f 12'
        sr = pe(get_sr_cmd, shell=True)
        sr_int = int(sr[0].strip())
        print(""Got samplerate {}, converting to 16000"".format(sr_int))
        # was assuming all were 48000
        convert = estdir + \
            ""bin/ch_wave $i -o tmp_$i -itype wav -otype wav -F 16000 -f {}"".format(sr_int)
        pe(""for i in *.wav; do echo %s; %s; mv tmp_$i $i; done"" % (convert, convert), shell=True)

        os.chdir(experiment_dir)
        txt_partial_path = txt_path  # vctkdir + ""txt/""
        """"""
        subfolders = sorted(os.listdir(txt_partial_path))
        # only p294 for now...
        subfolders = subfolder_select(subfolders)
        os.chdir(""database/txt"")
        for sf in subfolders:
            txt_path = txt_partial_path + sf + ""/*.txt""
            pe(""cp %s ."" % txt_path, shell=True)
        """"""
        os.chdir(""database/txt"")
        to_copy = os.listdir(txt_partial_path)
        if len([tc for tc in to_copy if tc[-4:] == "".txt""]) == 0:
            raise IOError(
                ""Unable to find any txt files in %s. Be sure the filenames end in .txt!"" % txt_partial_path)
        txt_match_path = txt_partial_path + ""/*.txt""
        for fi in glob.glob(txt_match_path):
            # escape string...
            fi = re.escape(fi)
            try:
                pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            except:
                from IPython import embed
                embed()
                raise ValueError()

        #pe(""cp %s ."" % txt_match_path, shell=True)

    do_state_align = False
    if do_state_align:
        raise ValueError(""Replace these lies with something that points at the right place"")
        os.chdir(merlin_dir)
        os.chdir(""misc/scripts/alignment/state_align"")
        pe(""bash -x setup.sh 2>&1"", shell=True)

        with open(""config.cfg"", ""r"") as f:
            config_lines = f.readlines()

        # replace FESTDIR with the correct path
        festdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""FESTDIR="" in l:
                festdir_replace_line = n
                break

        config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

        # replace HTKDIR with the correct path
        htkdir_replace_line = None
        for n, l in enumerate(config_lines):
            if ""HTKDIR="" in l:
                htkdir_replace_line = n
                break

        config_lines[htkdir_replace_line] = ""HTKDIR=%s\n"" % htkdir

        with open(""config.cfg"", ""w"") as f:
            f.writelines(config_lines)

        pe(""bash -x run_aligner.sh config.cfg 2>&1"", shell=True)
    else:
        os.chdir(merlin_dir)
        if not os.path.exists(""misc/scripts/alignment/phone_align/full-context-labels/full""):
            os.chdir(""misc/scripts/alignment/phone_align"")
            pe(""bash -x setup.sh 2>&1"", shell=True)

            with open(""config.cfg"", ""r"") as f:
                config_lines = f.readlines()

            # replace ESTDIR with the correct path
            estdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""ESTDIR="" in l and l[0] == ""E"":
                    estdir_replace_line = n
                    break

            config_lines[estdir_replace_line] = ""ESTDIR=%s\n"" % estdir

            # replace FESTDIR with the correct path
            festdir_replace_line = None
            for n, l in enumerate(config_lines):
                # EST/FEST
                if ""FESTDIR="" in l and l[0] == ""F"":
                    festdir_replace_line = n
                    break

            config_lines[festdir_replace_line] = ""FESTDIR=%s\n"" % festdir

            # replace FESTVOXDIR with the correct path
            festvoxdir_replace_line = None
            for n, l in enumerate(config_lines):
                if ""FESTVOXDIR="" in l:
                    festvoxdir_replace_line = n
                    break

            config_lines[festvoxdir_replace_line] = ""FESTVOXDIR=%s\n"" % festvoxdir

            with open(""config.cfg"", ""w"") as f:
                f.writelines(config_lines)

            with open(""run_aligner.sh"", ""r"") as f:
                run_aligner_lines = f.readlines()

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../cmuarctic.data"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../txt.done.data etc/txt.done.data\n""

            # Make the txt.done.data file
            def format_info_tup(info_tup):
                return ""( "" + str(info_tup[0]) + ' ""' + info_tup[1] + '"" )\n'

            # Now we need to get the text info
            txt_partial_path = txt_path  # vctkdir + ""txt/""
            cwd = os.getcwd()
            out_path = ""txt.done.data""
            out_file = open(out_path, ""w"")
            """"""
            subfolders = sorted(os.listdir(txt_partial_path))
            # TODO: Avoid this truncation and have an option to select subfolder(s)...
            subfolders = subfolder_select(subfolders)

            txt_ids = []
            for sf in subfolders:
                print(""Processing subfolder %s"" % sf)
                txt_sf_path = txt_partial_path + sf + ""/""
                for txtpath in os.listdir(txt_sf_path):
                    full_txtpath = txt_sf_path + txtpath
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                        assert len(r) == 1
                        # remove txt extension
                        name = txtpath.split(""."")[0]
                        text = r[0].strip()
                        info_tup = (name, text)
                        txt_ids.append(name)
                        out_file.writelines(format_info_tup(info_tup))
            """"""
            txt_ids = []
            txt_l_path = txt_partial_path
            for txtpath in os.listdir(txt_l_path):
                print(""Processing %s"" % txtpath)
                full_txtpath = txt_l_path + txtpath
                name = txtpath.split(""."")[0]
                wavpath_matches = [fname.split(""."")[0] for fname in os.listdir(wav_partial_path)
                                   if name in fname]
                for name in wavpath_matches:
                    # Need an extra level here for pavoque :/
                    with open(full_txtpath, 'r') as f:
                        r = f.readlines()
                    if len(r) == 0:
                        continue
                    if len(r) != 1:
                        new_r = []
                        for ri in r:
                            if ri != ""\n"":
                                new_r.append(ri)
                        r = new_r
                    if len(r) != 1:
                        print(""Something wrong in text extraction, cowardly bailing to IPython"")
                        from IPython import embed
                        embed()
                        raise ValueError()
                    assert len(r) == 1
                    # remove txt extension
                    text = r[0].strip()
                    info_tup = (name, text)
                    txt_ids.append(name)
                    out_file.writelines(format_info_tup(info_tup))
            out_file.close()
            pe(""cp %s %s/txt.done.data"" % (out_path, latest_feature_dir),
               shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cp ../slt_wav/*.wav"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = ""cp ../wav/*.wav wav\n""

            # Put wav file in the correct place
            wav_partial_path = experiment_dir + ""/database/wav""
            """"""
            subfolders = sorted(os.listdir(wav_partial_path))
            """"""
            if not os.path.exists(""wav""):
                os.mkdir(""wav"")
            cwd = os.getcwd()
            os.chdir(""wav"")
            """"""
            for sf in subfolders:
                wav_path = wav_partial_path + ""/*.wav""
                pe(""cp %s ."" % wav_path, shell=True)
            """"""
            wav_match_path = wav_partial_path + ""/*.wav""
            for fi in glob.glob(wav_match_path):
                fi = re.escape(fi)
                try:
                    pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
                except:
                    from IPython import embed
                    embed()
                    raise ValueError()
                #pe(""echo %s; cp %s ."" % (fi, fi), shell=True)
            #pe(""cp %s ."" % wav_match_path, shell=True)
            os.chdir(cwd)

            replace_line = None
            for n, l in enumerate(run_aligner_lines):
                if ""cat cmuarctic.data |"" in l:
                    replace_line = n
                    break

            run_aligner_lines[replace_line] = 'cat txt.done.data | cut -d "" "" -f 2 > file_id_list.scp\n'

            # FIXME
            # Hackaround to avoid harcoded 30 in festivox do_ehmm
            if not full_features:
                bdir = os.getcwd()

                # need to hack up run_aligner more..
                # do setup manually
                pe(""mkdir cmu_us_slt_arctic"", shell=True)
                os.chdir(""cmu_us_slt_arctic"")

                pe(""%s/src/clustergen/setup_cg cmu us slt_arctic"" % festvoxdir, shell=True)

                pe(""cp ../txt.done.data etc/txt.done.data"", shell=True)
                wmp = ""../wav/*.wav""
                for fi in glob.glob(wmp):
                    fi = re.escape(fi)
                    try:
                        pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                    except:
                        from IPython import embed
                        embed()
                        raise ValueError()
                    #pe(""echo %s; cp %s wav/"" % (fi, fi), shell=True)
                #pe(""cp ../wav/*.wav wav/"", shell=True)

                # remove top part but keep cd call
                run_aligner_lines = run_aligner_lines[:13] + \
                    [""cd cmu_us_slt_arctic\n""] + run_aligner_lines[35:]

                '''
                # need to change do_build
                # NO LONGER NECESSARY DUE TO FESTIVAL DEPENDENCE ON FILENAME

                os.chdir(""bin"")
                with open(""do_build"", ""r"") as f:
                    do_build_lines = f.readlines()

                replace_line = None
                for n, l in enumerate(do_build_lines):
                    if ""$FESTVOXDIR/src/ehmm/bin/do_ehmm"" in l:
                        replace_line = n
                        break

                do_build_lines[replace_line] = ""   $FESTVOXDIR/src/ehmm/bin/do_ehmm\n""

                # FIXME Why does this hang when not overwritten???
                with open(""edit_do_build"", ""w"") as f:
                    f.writelines(do_build_lines)
                '''

                # need to change do_ehmm
                os.chdir(festvoxdir)
                os.chdir(""src/ehmm/bin/"")

                # this is to fix festival if we somehow kill in the middle of training :(
                # all due to festival's apparent dependence on name of script!
                # really, really, REALLY weird
                if os.path.exists(""do_ehmm.bak""):
                    with open(""do_ehmm.bak"", ""r"") as f:
                        fix = f.readlines()

                    with open(""do_ehmm"", ""w"") as f:
                        f.writelines(fix)

                with open(""do_ehmm"", ""r"") as f:
                    do_ehmm_lines = f.readlines()

                with open(""do_ehmm.bak"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                replace_line = None
                for n, l in enumerate(do_ehmm_lines):
                    if ""$EHMMDIR/bin/ehmm ehmm/etc/ph_list.int"" in l:
                        replace_line = n
                        break

                max_n_itr = ehmm_max_n_itr
                do_ehmm_lines[replace_line] = ""    $EHMMDIR/bin/ehmm ehmm/etc/ph_list.int ehmm/etc/txt.phseq.data.int 1 0 ehmm/binfeat scaledft ehmm/mod 0 0 0 %s $num_cpus\n"" % str(
                    max_n_itr)

                # depends on *name* of the script?????????
                with open(""do_ehmm"", ""w"") as f:
                    f.writelines(do_ehmm_lines)

                # need to edit run_aligner....
                dbn = ""do_build""
                # FIXME
                # WHY DOES IT DEPEND ON FILENAME????!!!!!??????
                # should be able to call only edit_do_build label
                # but hangs indefinitely...
                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_prompts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_prompts\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build label"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s label\n"" % dbn

                replace_line = None
                for n, l in enumerate(run_aligner_lines):
                    if ""./bin/do_build build_utts"" in l:
                        replace_line = n
                        break
                run_aligner_lines[replace_line] = ""./bin/%s build_utts\n"" % dbn
                os.chdir(bdir)

            with open(""edit_run_aligner.sh"", ""w"") as f:
                f.writelines(run_aligner_lines)

            # 2>&1 needed to make it work?? really sketchy
            pe(""bash -x edit_run_aligner.sh config.cfg 2>&1"", shell=True)

    # compile vocoder
    os.chdir(merlin_dir)
    # set it to run on cpu
    pe(""sed -i.bak -e s/MERLIN_THEANO_FLAGS=.*/MERLIN_THEANO_FLAGS='device=cpu,floatX=float32,on_unused_input=ignore'/g src/setup_env.sh"", shell=True)
    os.chdir(""tools"")
    if not os.path.exists(""SPTK-3.9""):
        pe(""bash -x compile_tools.sh 2>&1"", shell=True)

    # slt_arctic stuff
    os.chdir(merlin_dir)
    os.chdir(""egs/slt_arctic/s1"")

    # This madness due to autogen configs...
    pe(""bash -x scripts/setup.sh slt_arctic_full 2>&1"", shell=True)

    global_config_file = ""conf/global_settings.cfg""
    replace_write(global_config_file, ""Labels"", ""phone_align"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Train"", ""1132"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Valid"", ""0"", replace_line=""%s=%s\n"")
    replace_write(global_config_file, ""Test"", ""0"", replace_line=""%s=%s\n"")

    pe(""bash -x scripts/prepare_config_files.sh %s 2>&1"" % global_config_file, shell=True)
    pe(""bash -x scripts/prepare_config_files_for_synthesis.sh %s 2>&1"" % global_config_file, shell=True)
    # delete the setup lines from run_full_voice.sh
    pe(""sed -i.bak -e '11d;12d;13d' run_full_voice.sh"", shell=True)

    pushd = os.getcwd()
    os.chdir(""conf"")

    acoustic_conf = ""acoustic_slt_arctic_full.conf""
    replace_write(acoustic_conf, ""train_file_number"", ""1132"")
    replace_write(acoustic_conf, ""valid_file_number"", ""0"")
    replace_write(acoustic_conf, ""test_file_number"", ""0"")

    replace_write(acoustic_conf, ""label_type"", ""phone_align"")
    replace_write(acoustic_conf, ""subphone_feats"", ""coarse_coding"")
    replace_write(acoustic_conf, ""dmgc"", ""60"")
    replace_write(acoustic_conf, ""dbap"", ""1"")
    # hack this to add an extra line in the config
    replace_write(acoustic_conf, ""dlf0"", ""1\ndo_MLPG: False"")

    if not full_features:
        replace_write(acoustic_conf, ""warmup_epoch"", ""1"")
        replace_write(acoustic_conf, ""training_epochs"", ""1"")
    replace_write(acoustic_conf, ""TRAINDNN"", ""False"")
    replace_write(acoustic_conf, ""DNNGEN"", ""False"")
    replace_write(acoustic_conf, ""GENWAV"", ""False"")
    replace_write(acoustic_conf, ""CALMCD"", ""False"")

    duration_conf = ""duration_slt_arctic_full.conf""
    replace_write(duration_conf, ""train_file_number"", ""1132"")
    replace_write(duration_conf, ""valid_file_number"", ""0"")
    replace_write(duration_conf, ""test_file_number"", ""0"")
    replace_write(duration_conf, ""label_type"", ""phone_align"")
    replace_write(duration_conf, ""dur"", ""1"")
    if not full_features:
        replace_write(duration_conf, ""warmup_epoch"", ""1"")
        replace_write(duration_conf, ""training_epochs"", ""1"")

    replace_write(duration_conf, ""TRAINDNN"", ""False"")
    replace_write(duration_conf, ""DNNGEN"", ""False"")
    replace_write(duration_conf, ""CALMCD"", ""False"")

    os.chdir(pushd)
    if not os.path.exists(""slt_arctic_full_data""):
        pe(""bash -x run_full_voice.sh 2>&1"", shell=True)

    pe(""mv run_full_voice.sh.bak run_full_voice.sh"", shell=True)

    os.chdir(merlin_dir)
    os.chdir(""misc/scripts/vocoder/world"")

    with open(""extract_features_for_merlin.sh"", ""r"") as f:
        ex_lines = f.readlines()

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""merlin_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'merlin_dir=""%s""' % merlin_dir

    ex_line_replace = None
    for n, l in enumerate(ex_lines):
        if ""wav_dir="" in l:
            ex_line_replace = n
            break

    ex_lines[ex_line_replace] = 'wav_dir=""%s""' % (experiment_dir + ""/database/wav"")

    with open(""edit_extract_features_for_merlin.sh"", ""w"") as f:
        f.writelines(ex_lines)

    pe(""bash -x edit_extract_features_for_merlin.sh 2>&1"", shell=True)

    os.chdir(basedir)
    os.chdir(""latest_features"")
    os.symlink(merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat"", ""audio_feat"")
    os.symlink(merlin_dir + ""/misc/scripts/alignment/phone_align/full-context-labels/full"", ""text_feat"")

    print(""Audio features in %s (and %s)"" % (os.getcwd() + ""/audio_feat"",
                                             merlin_dir + ""/egs/slt_arctic/s1/slt_arctic_full_data/feat""))
    print(""Text features in %s (and %s)"" % (os.getcwd() + ""/text_feat"", merlin_dir +
                                            ""/misc/scripts/alignment/phone_align/full-context-labels/full""))
    os.chdir(basedir)",_794.py,307,"'echo %s; cp %s wav/' % (fi, fi)",f'echo {fi}; cp {fi} wav/',1.0
https://github.com/google/capirca/tree/master/tests/lib/junipermsmpc_test.py,"def testProtocolAsNumber(self, protoname, protonum):
    expected = ('            application test-filtergood-term-numeric-app1 {\n'
                + '                protocol %s;') % protonum

    msmpc = junipermsmpc.JuniperMSMPC(
        policy.ParsePolicy(
            GOOD_HEADER_MIXED + GOOD_TERM_NUMERIC_PROTOCOL % protoname,
            self.naming), EXP_INFO)
    output = str(msmpc)
    self.assertIn(expected, output, output)",_815.py,2,('            application test-filtergood-term-numeric-app1 {\n' + '                protocol %s;') % protonum,f'            application test-filtergood-term-numeric-app1 {\n' + '                protocol {protonum};',1
https://github.com/yt-dlp/yt-dlp/tree/master/yt_dlp/extractor/vimeo.py,"def _fetch_page(self, album_id, authorization, hashed_pass, page):
        api_page = page + 1
        query = {
            'fields': 'link,uri',
            'page': api_page,
            'per_page': self._PAGE_SIZE,
        }
        if hashed_pass:
            query['_hashed_pass'] = hashed_pass
        try:
            videos = self._download_json(
                'https://api.vimeo.com/albums/%s/videos' % album_id,
                album_id, 'Downloading page %d' % api_page, query=query, headers={
                    'Authorization': 'jwt ' + authorization,
                })['data']
        except ExtractorError as e:
            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:
                return
        for video in videos:
            link = video.get('link')
            if not link:
                continue
            uri = video.get('uri')
            video_id = self._search_regex(r'/videos/(\d+)', uri, 'video_id', default=None) if uri else None
            yield self.url_result(link, VimeoIE.ie_key(), video_id)",_931.py,12,'https://api.vimeo.com/albums/%s/videos' % album_id,f'https://api.vimeo.com/albums/{album_id}/videos',1.0
https://github.com/yt-dlp/yt-dlp/tree/master/yt_dlp/extractor/vimeo.py,"def _fetch_page(self, album_id, authorization, hashed_pass, page):
        api_page = page + 1
        query = {
            'fields': 'link,uri',
            'page': api_page,
            'per_page': self._PAGE_SIZE,
        }
        if hashed_pass:
            query['_hashed_pass'] = hashed_pass
        try:
            videos = self._download_json(
                'https://api.vimeo.com/albums/%s/videos' % album_id,
                album_id, 'Downloading page %d' % api_page, query=query, headers={
                    'Authorization': 'jwt ' + authorization,
                })['data']
        except ExtractorError as e:
            if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:
                return
        for video in videos:
            link = video.get('link')
            if not link:
                continue
            uri = video.get('uri')
            video_id = self._search_regex(r'/videos/(\d+)', uri, 'video_id', default=None) if uri else None
            yield self.url_result(link, VimeoIE.ie_key(), video_id)",_931.py,13,'Downloading page %d' % api_page,f'Downloading page {api_page}',1.0
https://github.com/tribe29/checkmk/tree/master/tests/testlib/web_session.py,"def folder_exists(self, folder_path):
        try:
            result = self._api_request(
                ""webapi.py?action=get_folder"",
                {
                    ""request"": json.dumps(
                        {
                            ""folder"": folder_path,
                        }
                    ),
                },
            )
        except AssertionError as e:
            if ""does not exist"" in ""%s"" % e:
                return False
            raise

        assert isinstance(result, dict)
        return ""folder"" in result",_957.py,14,'%s' % e,f'{e}',1.0
https://github.com/3b1b/videos/tree/master/_2016/eola/chapter8p2.py,"def write_function(self):
        brace = Brace(self.det_text, DOWN)
        number_text = brace.get_text(""Number"")
        self.play(Transform(self.title, self.title.not_real))
        self.wait()
        self.play(FadeOut(self.definitions))
        self.play(
            GrowFromCenter(brace),
            Write(number_text)
        )
        self.wait()

        x, y, z = variables = list(map(Tex, ""xyz""))
        for var, entry in zip(variables, self.u_entries):
            var.scale(0.8) 
            var.move_to(entry)
            entry.target = var
        brace.target = Brace(z)
        brace.target.stretch_to_fit_width(0.5)
        number_text.target = brace.target.get_text(""Variable"")
        v_brace = Brace(self.matrix.get_mob_matrix()[0, 1], UP)
        w_brace = Brace(self.matrix.get_mob_matrix()[0, 2], UP)
        for vect_brace, tex in (v_brace, self.v_tex), (w_brace, self.w_tex):
            vect_brace.stretch_to_fit_width(brace.target.get_width())
            new_tex = tex.copy()
            vect_brace.put_at_tip(new_tex)
            vect_brace.tex = new_tex
        func_tex = Tex(
            ""f\\left(%s\\right)""%matrix_to_tex_string(list(""xyz""))
        )
        func_tex.scale(0.7)
        func_input = Matrix(list(""xyz""))
        func_input_template = VGroup(*func_tex[3:-2])
        func_input.set_height(func_input_template.get_height())
        func_input.next_to(VGroup(*func_tex[:3]), RIGHT)
        VGroup(*func_tex[-2:]).next_to(func_input, RIGHT)
        func_tex[0].scale(1.5)

        func_tex = VGroup(
            VGroup(*[func_tex[i] for i in (0, 1, 2, -2, -1)]),
            func_input
        )
        func_tex.next_to(self.equals, LEFT)

        self.play(
            FadeOut(self.title),
            FadeOut(self.triple_cross),
            *[
                Transform(mob, mob.target)
                for mob in [brace, number_text]
            ]
        )
        self.play(*[
            Transform(mob, mob.target)
            for mob in self.u_entries
        ])
        self.play(*[
            Write(VGroup(vect_brace, vect_brace.tex))
            for vect_brace in (v_brace, w_brace)
        ])
        self.wait()
        self.play(Write(func_tex))
        self.wait()

        self.func_tex = func_tex
        self.variables_text = VGroup(brace, number_text)",_962.py,29,'f\\left(%s\\right)' % matrix_to_tex_string(list('xyz')),"f""f\\left({matrix_to_tex_string(list('xyz'))}\right)""",1.0
https://github.com/williballenthin/python-evtx/tree/master/tests/test_issue_39.py,"def get_child(node, tag, ns=""{http://schemas.microsoft.com/win/2004/08/events/event}""):
    return node.find(""%s%s"" % (ns, tag))",_963.py,2,"'%s%s' % (ns, tag)",f'{ns}{ns}',1.0